\documentclass{article} % <<<

% Keep fontenc and inputenc them in this order.
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{booktabs}
\usepackage{fancyvrb}
\usepackage{graphics}
\usepackage{mathtools}
\usepackage{microtype}  % do not remove
\usepackage{multirow}
\usepackage{proof}
\usepackage{pygmentize}
\usepackage{rgalg}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{xspace}

\usepackage{tikz}
\usetikzlibrary{arrows,positioning,fit,backgrounds,shadows,calc}

\usepackage[colorlinks]{hyperref} % keep it last to avoid some warnings

\RecustomVerbatimEnvironment{Verbatim}{BVerbatim}{}
\definecolor{darkred}{rgb}{0.4,0,0}
\definecolor{darkblue}{rgb}{0,0,0.4}
\definecolor{verylightgray}{rgb}{0.9,0.9,0.9}
\definecolor{lightblue}{rgb}{0,0,0.9}
% comment the next line for printing
\hypersetup{colorlinks,linkcolor=darkblue,citecolor=darkblue,urlcolor=darkblue}
\hypersetup{
  pdftitle={Runtime Verification Based on Register Automata},
  pdfauthor={Dino Distefano and Radu Grigore and Rasmus Lechedahl Petersen and Nikos Tzevelekos}}

\title{Runtime Verification Based on Register Automata}
\author
  {     Dino Distefano\thanks{Queen Mary University of London}
  \and  Radu Grigore\footnotemark[1]
  \and  Rasmus Lerchedahl Petersen\thanks{Microsoft Research Cambridge}
  \and  Nikos Tzevelekos\footnotemark[1] }
\date{}

\renewcommand{\sectionautorefname}{Section}
\renewcommand{\subsectionautorefname}{\sectionautorefname}

\newcommand{\noterg}[2]{\textcolor{gray}{[\textcolor{red}{#1}: #2]}}
\newcommand{\rg}[1]{\noterg{rg}{#1}}
\newcommand{\rlp}[1]{\noterg{rlp}{#1}}
\newcommand{\dd}[1]{\noterg{dd}{#1}}
\newcommand{\dinocomment}[1]{\dd{#1}}

\newcommand{\A}{\ensuremath{\mathcal{A}}}
\newcommand{\B}{\ensuremath{\mathbb{B}}}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\comma}[1]{{\lineskiplimit=0pt \oalign{\relax#1\crcr\hidewidth,\hidewidth}}}
\newcommand{\delimitVerbatim}{\par\nobreak\medskip\noindent}
\newcommand{\eoe}{\hskip5mm\null\nobreak\hfill\vrule height1ex width1ex}
\newcommand{\error}{\ensuremath{\textcolor{darkred}{\mathtt{error}}}\xspace}
\newcommand{\eval}[1]{[[#1]]}
\newcommand{\limp}{\Rightarrow}
\newcommand{\pattern}[1]{\ensuremath{\mathtt{\underline{#1}}}}
\newcommand{\pmap}{\rightharpoonup}
\newcommand{\set}[1]{\ensuremath{\mathsf{#1}}}
\newcommand{\start}{\ensuremath{\mathtt{start}}\xspace}
\newcommand{\verbline}[2][]{\[\text{\Verb@#2@}#1\]}

\newcommand{\quoteindent}{1.5\parindent} % could be re-defined before a quote
\newcommand{\eqquote}[2]{{%
  \refstepcounter{equation}\label{#2}%
  \newdimen\qi\qi=\quoteindent
  \setbox0=\vbox{\advance\hsize by-2\qi\noindent\em#1}%
  \newdimen\x\x=\ht0 \advance\x by\dp0%
  \setbox1=\vbox to\x{\vss\hbox{(\arabic{equation})}\vss}%
  \leavevmode\\[1ex]%
  \hbox to\hsize{\hskip\qi\box0\hfil\box1}%
  \\[1ex]}}
\newcommand{\emquote}[1]{{%
  \\[1ex]%
  \newdimen\qi\qi=\quoteindent%
  \hbox to\hsize{\hfil\vbox{\advance\hsize by-2\qi\noindent\em#1}\hfil}%
  \\[1ex]}}

% rg: I tend to give grammars in BFS order
\def\grammar#1{{
  \footnotesize
  \def\b##1{{\rm\Verb@##1@}}\def\*{$^*$}\def\?{$^?$}\def\({$($}\def\){$)$}
  \def\|{$\mid$}\def\+{$^+$}
  \smallskip
  \hbox to\hsize{\hfil\vbox{\halign{\hfil\it##&$\;::=\;$\it##\hfil&\qquad\rm##\hfil\cr#1}}\hfil}
  \smallskip
}}


\newtheorem{lemma}{Lemma}
\providecommand*{\lemmaautorefname}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{theorem}{Theorem}

\theoremstyle{definition}
\newtheorem{definition}{Definition}
\providecommand*{\definitionautorefname}{Definition}
\newtheorem{example}{Example}
\providecommand*{\exampleautorefname}{Example}

\theoremstyle{remark}
\newtheorem{notation}{Notation}
\newtheorem{remark}{Remark}

% For the final version, switch then comment-status of the following lines.
\overfullrule=5pt
%\renewcommand{\noterg}[2]{}

\showboxdepth=10
\showboxbreadth=30
% >>>
\begin{document}
\maketitle
\begin{abstract} % <<<
We introduce a new formal framework aimed at checking temporal safety properties of object-oriented programs.
The underpinning theoretical foundations of our framework is an extended class of {\em register automata}.
As registers' values can be updated, our automata are able to express highly complex properties of systems involving multiple interacting objects.
Specifications are then used to instrument Java bytecode so that their violations can be automatically detected at runtime.
The tradeoff between the coverage and the overhead of the monitoring
system is tunable by means of a number of  parameters.
We validated our technique by checking several safety properties on large open source projects.
\rg{Remove `we'; it clearly doesn't mean `us and the reader'.}
\end{abstract}

% >>>
\section{Introduction} % <<<

Runtime verification is a technique where the behaviour of programs is monitored at runtime to check whether executions
can violate certain safety properties.
Systems for runtime verification stand somehow in between classic verification and testing: they work on the actual system (as testing) but check violations of temporal properties as, for example, it is done in model checking. Compared to traditional formal verification techniques, runtime verification systems check only certain program executions, however, the error reports are accurate and detected violations represent real bugs in the program.

In the context of object-oriented programming  leading runtime verification techniques include JavaMOP~\cite{dblp:journals/sttt/meredithjgcr12}, QVM~\cite{arnold:2008}, Tracematches~\cite{dblp:conf/oopsla/allanachklmsst05}, and techniques based on typestate~\cite{strom1986,dblp:conf/oopsla/bierhoffa07,dblp:conf/oopsla/naeeml08,disney2011,ball2002}. Although powerful,  these methods present some limitations. For example, either   in terms of  language expressivity, or in the ability to express concisely properties of the interaction of several objects
over time (typestate), or in concisely expressing  properties requiring an unbounded number of different object re-bindings (sometimes called parameters in the runtime verification community).

Register Automata~\cite{dblp:conf/focs/kaminskif90} are automata where
a number of registers are used to store and compare data. The values
of registers can be updated over time, and data can be taken from unbounded domains (e.g., the set of object references). Thus register automata provide a powerful device for reasoning about temporal
relations of a (possibly unbounded) number of objects in a finite manner. They have been studied extensively from the theoretical point of
view and essential results for their analysis have been established (e.g., decidability of emptiness, closure under intersection, and so forth).

Thus, it seems sensible to attempt an approach to runtime verification
taking register automata as the starting point. The aim is to
exploit the flexibility and the power of registers to
address certain properties not easily dealt with in other approaches.
On the formal side, we started from register automata and have extended them driven by typical properties required in real-world object-oriented systems.
The extension has been careful crafted to be able to define the precise mathematical connection with register automata, and yet,
make it easy for programmers to express properties of their code. This process has resulted in the definition of two new classes of
automata: a high-level and a low-level one. In the high-level automata, temporal properties about programs are naturally expressed. Low-level automata,
on the other hand, simplify the formal correspondence with  register automata.
Finally we defined a formal language -- called TOPL (Temporal Object Property Language) -- mapping directly on the
high-level automata.

We complement the theoretical construction with a practical tool.
We have implemented TOPL  in a runtime parametric verification framework that can be used by Java programmers to express rigorous temporal
properties about their programs. These properties will then be automatically checked by the system.
The formal correspondence between the properties and register automata
defined in this paper gives a rigorous mathematical foundation to
the approach and allows us to reuse many of the results for register automata on TOPL automata. For example, given a TOPL property, we can decide whether its language is empty.  The formal development is completely hidden from
the programmer.
Our system can be tuned  in terms of coverage,  overhead, and trace reporting by means of a number of parameters.

\paragraph{Contributions.}
In summary, the contributions of this paper are:
\begin{itemize}
\item We define TOPL, a formal specification language tailored to express properties involving object interactions over time in a way that is familiar to object-oriented programmers.
\item We define a precise formal semantics for TOPL, making it suitable for program analysis, both static and dynamic.
\item We define a precise formal correspondence between TOPL automata and register automata.
In particular we prove that they are equally expressive. As our proof is constructive, this implies that the decidability results for register automata hold also for TOPL automata. Consequently we can decide several features of TOPL specifications (e.g., language emptiness).
\item We have implemented our parametric framework  in a tool that automatically check at runtime violations of TOPL properties in Java programs. A number of parameters are used to tune the precision of the system.

\item We report on experiments of running our tool on large open-source projects. The results are encouraging (e.g., we have found
an interesting and previously unknown  concurrency bug in the DaCapo suite).
\end{itemize}


The paper is organized as follows.
\autoref{sec:motivating-examples} gives some example properties motivating TOPL.
\autoref{sec:overview} provides background of register automata and defines the basis of our formalism.
\autoref{sec:topl_automata} introduces TOPL automata and proves the equivalence with register automata.
\autoref{sec:topl} defines the TOPL property language and its semantics.
\autoref{sec:examples} describes several example properties using TOPL\null.
\autoref{sec:implementation} describes  the implementation of the runtime  verification system.
\autoref{sec:results} discusses the experimental results and \autoref{sec:related}  related work.
Finally, \autoref{sec:conclusions} concludes the paper and describes our plans for future work.

%>>>
\section{Motivating Examples} %<<<
\label{sec:motivating-examples}
Interaction among objects is at the core of the object-oriented paradigm.
Consider for example  Java collections. A typical property one would want to state  is:
\eqquote{If one iterator modifies its collection, then other existing iterators of the same collection become invalid, which means they cannot be used further.}{q:concur-it}
The formalization of the above constraint is non-trivial since it needs to keep track of {\em several objects} (at least two iterators, and one collection) and their {\em interaction over time}.

A slightly more complex scenario is described by classes in Figure~\ref{fig:first.java}.
Class {\tt CharArray} manipulates an array of chars and implements the {\tt Str} interface.
Class {\tt Concat} is used to concatenate two object of type {\tt Str}. Also {\tt Concat} implements
 {\tt Str}.
Consider the case where {\tt Concat} is used to implement a  {\em rope} data structure.\footnote{ A rope is a binary tree shaped data structure for efficiently storing and manipulating very long strings~\cite{DBLP:journals/spe/BoehmAP95}.}
Rope's operations like insert, concat, delete may update the shape of the tree and references to its root.
In this case we may have two (or more) collections {\em sharing} some elements. Consequently iterators operating on these different collections may invalidate each other. We need to modify~\eqref{q:concur-it} increasing its complexity:
\eqquote{If one iterator modifies its collection, then other existing iterators of collections sharing some elements become invalid, which means they cannot be used further.}{q:concur-it2}

\paragraph{Re-binding of specification variables.}
Now let's consider the case where we want to perform {\em taint checking} for input coming from a web form.  What we want to check is the following
property:
\eqquote{Any value introduced by the {\tt input()} method should not
  reach the  {\tt sink()} method without first passing through the {\tt sanitizer()} method.}{q:concur-it3}
This property is at first sight simple. However, it's difficulty can vary depending on the context. Consider in fact the case where
the input is constructed by concatenating strings from the web form, by for example, using ropes implemented with class {\tt Concat}.
The number of user inputs, and therefore of concatenations, is not known a priori and in general unbounded.
Consequently we will have a possibly unbounded number of tainted objects.
In a temporal specification, we would then need either different logical variables for each different tainted objects or
the ability to {\em re-bind} (or {\em update}) variables in the temporal specification in a way that, at the semantic level, we capture all the tainted objects. For an unbounded number of object, re-binding specification variables with
different values during the computation helps the specification to be
kept finite.

\begin{figure}[t] % first example <<<
%\include{IncorrectIteratorUse}
\include{Taint}
\caption{A first example: Java code}
\label{fig:first.java}
\end{figure}
%

The need for rebinding of variables in the specification arises also in other contexts. For example,
when  reasoning about the evolving shape of dynamically allocated data-structures.
Consider the following loop using a list:
 \begin{verbatim}
  while (l.next()!=null) {
     // here using the list l in some way...
     ......
  }
\end{verbatim}
If the list {\tt l} is circular or pan-handle shaped, one of the problem could be that the loop will diverge.
Being a violation of a liveness property (termination), divergence cannot be observed at runtime in finite time and therefore it is harder to debug.
If we have obtained the list by calling a third party library, we
would want to check the following property:\footnote{Of course, one
  can write a method (to call before entering the loop) which
  traverses the list and check whether it is circular or
  pan-handle. However, when the scope of the list is not clearly
  defined, these kind of explicit checks become cumbersome and error
  prone.}
\eqquote{The shape of the list should be neither circular nor pan-handle.}{q:concur-it4}
We will see in Section~\ref{sec:examples} that also the encoding of properties of this kind requires the ability to update the
value of the specification variables.  This is because the way to encode the property is by detecting, when using the list, that we reach an element we have seen before.

%The following TOPL properties test the shape of a linked list and
%reports an error if it is cyclic or it has the pan-handle shape (i.e.,
%there is a lasso at some point).
%Directives are omitted.
%%
%\delimitVerbatim
%\begin{Verbatim}[commandchars=\\\{\}]
% property ListNotCyclic
%   start -> start: *
%   start -> a: \pattern{X} := *.getList()
%   a -> a:     \pattern{X} := x.next()
%   a -> b:     \pattern{Y} := x.next()
%   b -> b:     \pattern{Y} := y.next()
%   b -> error: x := y.next()
%   a -> error: x := x.next()
%\end{Verbatim}
%\delimitVerbatim
%The idea is that this property will bind the property variable $x$ with any possible object in the list, and the $y$ with any possible successors (via the next field) of the current binding of $x$.
%Therefore, if there is a lasso, in the list, this will be detected when a new binding of $y$ via a \texttt{b -> b} becomes equal to the binding of $x$.
%The transition \texttt{a ->error} detects the case where there is an object pointing to itself.

%
%The following property detects when a dictionary overwrite one of its bindings.
%\delimitVerbatim
%\begin{Verbatim}[commandchars=\\\{\}]
% property BadDictionary
%   message "dictionary overwrites its bindings"
%   observe <Dictionary.*>
%   prefix <Dictionary>
%   start -> start: *
%   start -> written:   \pattern{D}.put(\pattern{K}, \pattern{V})
%   written -> written: d.put(k, \pattern{V})
%   written -> error:   !v := d.get(k)
%\end{Verbatim}
%\delimitVerbatim
%The overwrite is detected by the guard which checks if the value associated with a key $k$ is the same as the original binding recorded in the property variable $v$.

% >>>
% >>>
\section{Overview and Background}\label{sec:overview} % <<<

\autoref{fig:concepts} shows the main concepts of concern.
Register automata are well-studied devices, introduced decades ago.
The gap between TOPL properties and register automata is filled by two semantic models, namely high-level and low-level TOPL automata.
The high-level model (rollback TOPL automata) is better suited for implementation;
the low-level model (simple TOPL automata) is easier to analyze.

The target of an arrow is at least as expressive as its source.
All three automata models have the same expressivity.
In general, decision problems on automata (such as membership, emptiness, language inclusion), are either decidable for all three models, or undecidable for all three models.
However, decidable problems do not necessarily have the same complexity for the three models.

\begin{figure}[th]\centering\small
\begin{tikzpicture}[auto,node distance=4mm]
  \node (lang) {TOPL properties};
  \node (rtopl) [below=of lang] {rollback TOPL automata};
  \node (topl) [below=of rtopl] {simple TOPL automata};
  \node (ra) [below=of topl] {register automata};
  \path[draw,->,>=latex]
    (lang) edge (rtopl)
    (rtopl) edge[<->] (topl)
    (topl) edge[<->] (ra);
\end{tikzpicture}
\caption{Main concepts}
\label{fig:concepts}
\end{figure}

We review here register automata and several results about them.
Together with the reductions presented later, these results imply similar results about TOPL automata.

\subsection{Generic Automata}

Both register automata and TOPL automata are special cases of a generic automaton that this section defines.
A \emph{letter} $\ell$ is an $n$-tuple $(v_1,\ldots,v_n)$ of \emph{values} from a possibly infinite set~$V$;
we denote the \emph{alphabet} by~$\Sigma=V^n$.
A \emph{store} $s$ is an $m$-tuple $(u_1,\ldots,u_m)$ of values;
we denote the set of stores by $S=V^m$.
A \emph{register} $i$ is an integer that identifies a component of the store;
the set of registers is $[m]=\{1,2,\ldots,m\}$.
A \emph{guard} $g$ is a formula in some logic interpreted over pairs of letters and stores;
we write $(s,\ell)\models g$ to denote that store $s\in S$ and the letter $\ell\in\Sigma$ satisfy the guard~$g$, and we denote the set of guards by~$G$.
An \emph{action} $a$ is a small program acting on stores, which has relational semantics;
we denote the set of actions by $A=\Sigma\to(S\times S\to 2)$.
Thus, an action applied to a letter $a(\ell)$ is a relation on stores.
A \emph{label} $\lambda$ is a pair $(g,a)$ of a guard~$g$ and an action~$a$;
we denote the set of labels by $\Lambda=G\times A$.

\begin{definition}\label{def:automaton}
Let $\Lambda_t\subset\Lambda$ be a countable set of labels.
A \emph{$t$-automaton}~${\cal A}$ with $m$~registers over $n$-tuples of values from the set~$V$ consists of
\begin{itemize}
\item a finite set~$Q$ of states
\item an initial state $q_0\in Q$
\item an initial store $s_0\in S$
\item a set $F\subseteq Q$ of final states
\item a finite transition relation $\delta\subseteq Q\times\Lambda_t\times Q$
\end{itemize}
\end{definition}
The definition is parametric in the set~$\Lambda_t$.
This set is required to be countable so that automata are finitely representable.
Register automata correspond to~$\Lambda_{\rm R}$,
TOPL automata correspond to~$\Lambda_{\rm TOPL}$.
Both $\Lambda_{\rm R}$~and~$\Lambda_{\rm TOPL}$ are defined later.

A \emph{configuration}~$x$ is a pair~$(q,s)$ of a state~$q$ and a store~$s$;
we denote the set of configurations by $X=Q\times S$.
The \emph{initial} configuration is $(q_0,s_0)$.
A configuration is \emph{final} when its state is final.
The configuration graph of the $t$-automaton is a subset of $X\times\Sigma\times X$.
We write \[x_1\stackrel{\ell}{\to}_{\cal A}x_2\] to mean that $(x_1,\ell,x_2)$ is in the configuration graph of~${\cal A}$.
If the $t$-automaton is clear from the context, we omit the subscript.

\begin{definition}\label{def:cgraph}
The \emph{configuration graph} of a $t$-automaton consists of exactly those configuration transitions \[ (q_1,s_1) \stackrel{\ell}{\to} (q_2,s_2) \] for which there exists a $t$-automaton transition $(q_1,(g,a),q_2)\in\delta$ such that $(s_1,\ell)\models g$ and $(s_1,s_2)\in a(\ell)$.
\end{definition}
A $t$-automaton is \emph{nondeterministic} when its configuration graph contains two distinct transitions that have the same source~$x_1$ and are labeled by the same letter~$\ell$:
\[ \text{$x_1\stackrel\ell\to x_2$ and $x_1\stackrel\ell\to x_3$,\quad with $x_2\ne x_3$} \]
Otherwise, the $t$-automaton is \emph{deterministic}.

The \emph{language}~${\cal L}({\cal A})$ of a $t$-automaton~${\cal A}$ is the set of words that label walks from the initial configuration to some final configuration:
\[ {\cal L}({\cal A}) =
  \{\,\ell_1\ldots\ell_k\mid \text{$x_0$ initial,
  $x_{i-1}\stackrel{\ell_i}\to_{\cal A} x_i$ for $i\in[k]$,
  $x_k$ final}\,\}\]
Being a walk rather than a path, the configurations $x_0$,~$x_1$, \dots,~$x_k$ need not be distinct.

\subsection{Register Automata}

\emph{Register automata} are $t$-automata with $n=1$ and labels from~$\Lambda_{\rm R}$.
Labels in $\Lambda_{\rm R}$ use two kinds of guards, interpreted as follows:
\begin{align*}
\bigl((u_1,\ldots,u_m),v\bigr)&\models{\sf fresh}
  &&\iff &&\text{$u_i\ne v$ for all $i$} \\
\bigl((u_1,\ldots,u_m),v\bigr)&\models{\sf eq}\,i
  &&\iff &&\text{$u_i=v$}
\end{align*}
Labels in~$\Lambda_{\rm R}$ use two kinds of actions, defined as follows:
\begin{align*}
\bigl((v_1,\ldots,v_m),(v'_1,\ldots,v'_m)\bigr) &\in ({\sf nop})(u)
  &&\iff &&\text{$v'_k=v_k$ for all~$k$} \\
\bigl((v_1,\ldots,v_m),(v'_1,\ldots,v'_m)\bigr) &\in ({\sf set}\,i)(u)
  &&\iff && v'_k=\begin{cases}u&\text{if $k=i$}\\v_k&\text{if $k\ne i$}\end{cases}
\end{align*}
The labels of a register automaton are
\begin{align*}
\Lambda_{\rm R} =
       \{\,({\sf fresh},{\sf set}\,i)\mid i\in[m]\,\}
  \cup \{\,({\sf eq}\,i,{\sf nop})\mid i\in[m]\,\}
\end{align*}

There are several variants of definitions for register automata in the literature.
Our variant corresponds directly to what Neven et al~\cite{dblp:conf/mfcs/nevensv01} call 1N-RA (for `one-way non-deterministic register automata').

\begin{example}\label{ex:ra1}
The language $\{\,abc\mid\text{$a\ne c$ and $b\ne c$}\,\}\subset V^*$ is recognized by the following register automaton with $3$~registers over the alphabet $\Sigma=V\cup\{\bot\}$:
\begin{itemize}
\item $Q=\{1,2,3,4\}$
  and $q_0=1$
  and $s_0=(\bot,\bot,\bot)$
  and $F=\{4\}$
\item the set of transitions is
\begin{align*}\delta =\{ & \bigl(1,({\sf fresh},{\sf set}\,1),2\bigr), \ \bigl(2,({\sf fresh},{\sf set}\,2),3\bigr), \\
& \bigl(2,({\sf eq}\,1,{\sf nop}),3\bigr), \bigl(3,({\sf fresh},{\sf set}\,1),4\bigr) \}.
\end{align*}
\end{itemize}
Observe that:
(1)~The two parallel transitions from 2~to~3 are needed because labels cannot have the shape $({\sf true},{\sf set}\,i)$; in fact, we have not even defined yet the guard {\sf true}.
(2)~Only values from~$s_0$ may appear multiple times in a store; in this case, only~$\bot$.
(3)~Register~3 ensures that $\bot$ will not appear in the third position of words, which is a risk because we extended the alphabet.
(4)~The action of the last transition is superfluous, but required by the definition.
\eoe
\end{example}

\begin{theorem}\label{th:ra}
The following properties of register automata are known:
\begin{enumerate}
\item The emptiness problem is coNP-complete~\cite{dblp:journals/tcs/sakamotoi00}.
\item The membership problem is NL-complete~\cite{dblp:conf/mfcs/nevensv01} and NP-complete~\cite{dblp:journals/tcs/sakamotoi00}.
\item The inclusion, equivalence, and universality problems are decidable for $2$~registers~\cite{dblp:conf/focs/kaminskif90,dblp:conf/mfcs/nevensv01}.
\item The inclusion, equivalence, and universality problems are undecidable in general~\cite{dblp:conf/mfcs/nevensv01}.
\item Register automata are closed under union, intersection, concatenation, and Kleene star~\cite{dblp:conf/focs/kaminskif90}.
\item Register automata are \emph{not} closed under complementation and reversal~\cite{dblp:conf/focs/kaminskif90}.
\item Nondeterministic register automata are strictly more expressive than deterministic register automata~\cite{dblp:conf/focs/kaminskif90}.
\item The language ${\cal L}({\cal A})\cap C^*$ is regular for any register automaton~${\cal A}$ and any finite subset $C\subset V$ of values~\cite{dblp:conf/focs/kaminskif90}.
\end{enumerate}
\end{theorem}

These results have analogues for TOPL automata.

\subsection{Extended Automata}

The notion of extended $t$-automata, which is defined here, simplifies the reductions from \autoref{sec:topl_automata}.
An extended $t$-automaton is an algorithm that describes a $t$-automaton.
The reductions in \autoref{sec:topl_automata} are simpler because they describe algorithms for constructing extended $t$-automata, rather than describing algorithms for constructing $t$-automata.


%>>>
\section{TOPL Automata}\label{sec:topl_automata} % <<<

We now gradually move towards a model that is better suited for runtime verification of Java programs.

\subsection{Simple TOPL Automata} %<<<

TOPL automata work with the alphabet $\Sigma=V^n$ for some~$n\in\N$, unlike register automata, which force $n=1$.
It is then natural to consider different guards and actions, which handle specific components of the letters.
TOPL guards are the following:
\begin{align*}
G_{\rm TOPL} &\;::=\; {\sf eq}\,i=j \mid
{\sf neq}\,i\ne j \mid
 {\sf true} \mid
G_{\rm TOPL} \mathrel{\sf and} G_{\rm TOPL}
\end{align*}
If $n=1$, we write $({\sf eq}\,i)$ instead of $({\sf eq}\,i=1)$, and $({\sf neq}\,i)$ instead of $({\sf neq}\,i\ne1)$.
Recall that $({\sf set}\,i)$ abbreviates $({\sf set}\,i:=1)$.
The guards are interpreted as follows:
\begin{align*}
\bigl((u_1,\ldots,u_m),(v_1,\ldots,v_n)\bigr) &\models {\sf eq}\,i=j
  &&\text{iff $u_i=v_j$} \\
\bigl((u_1,\ldots,u_m),(v_1,\ldots,v_n)\bigr) &\models {\sf neq}\,i\ne j
  &&\text{iff $u_i\ne v_j$}
\end{align*}
and
\begin{align*}
(s,\ell) &\models {\sf true}
  &&\text{always} \\
(s,\ell) &\models g_1\mathrel{\sf and} g_2
  &&\text{iff $(s,\ell)\models g_1$ and $(s,\ell)\models g_2$}
\end{align*}

We can now define TOPL automata.

\begin{definition}
A \emph{TOPL automaton} is an automaton whose guards are from the set~$G_{\rm TOPL}$ (defined above) and whose actions are sequences of assignments (defined in \autoref{sec:overview}).
\end{definition}

\begin{example}\label{ex:topl1}
Consider again the language $\{\,abc\mid\text{$a\ne c$ and $b\ne c$}\,\}$.
It is recognized by the following TOPL automaton with $2$~registers over the alphabet $\Sigma=V$:
\begin{itemize}
\item $Q=\{1,2,3,4\}$ and $q_0=1$ and $F=\{4\}$
\item $\delta$ consists of
  $\bigl(1,({\sf true}, {\sf set}\,1),2\bigr)$
  and $\bigl(2,({\sf true}, {\sf set}\,2),3\bigr)$
  and $\bigl(3,({\sf neq}\,1\mathrel{\sf and}{\sf neq}\,2, {\sf nop}),4\bigr)$.
\end{itemize}
Any initial store~$s_0$ works.
\eoe
\end{example}

It is not difficult to see that TOPL automata are at least as expressive as register automata.

\begin{lemma}[RA to TOPL]\label{lemma:ra-to-topl}
There exists an algorithm that, given a register automaton~${\cal A}$ over the alphabet~$V$, with $m$~registers, $|Q|$~states, and $|\delta|$~transitions, builds a TOPL automaton~${\cal A}'$ over the alphabet $V$, with $m$~registers, $|Q|$~states, and $|\delta|$~transitions such that
\[w\in{\cal L}({\cal A}) \iff w\in{\cal L}({\cal A}') \]
\end{lemma}
\begin{proof}
The guard ${\sf fresh}$ is encoded as the guard ${\sf neq}\,1 \mathrel{\sf and} \ldots \mathrel{\sf and}{\sf neq}\,m$.
All other guards and actions remain unchanged.
\end{proof}

It is relatively harder to establish that TOPL automata are at most as expressive as register automata.
There are three main ingredients in the proof.
First, tuples $(v_1,\ldots,v_n)$ are unpacked into words $v_1\ldots v_n$; correspondingly, transitions $q\to q'$ become paths $q\to q_1\to\cdots\to q_{n-1}\to q'$.
Second, register~$i$ is simulated by register~$r(i)$, where $r\in[m]\to[m]$ is encoded in the state, such that values are not repeated in registers, as required by register automata.
Third, locally fresh values are written to an extra register, because register automata never ignore such values.

On its own, the second ingredient is the same as the proof of Kaminski and Francez~\cite{dblp:journals/tcs/kaminskif94} that their M-automata are equally expressive to register automata.
In the proof below, however, the first two ingredients (unpacking tuples and ensuring that values do not repeat) are blended together to improve the bounds.
The encoding of the function~$r$ leads to a $m^m$ expansion, in the worst case.
It turns out that a similar function is needed for unpacking tuples, which would lead to another similar expansion if the first two ingredients would not be mixed.

Consider the label $({\sf eq}\,1=2,{\sf set}\,1:=1)$, with the alphabet~$V^2$.
When tuples are unpacked, it would be tempting to replace it by the two labels, $({\sf true},{\sf set}\,1)$ and $({\sf eq}\,1,{\sf nop})$, one for each component of the tuple.
But, this would be incorrect, as the second component should be compared to the old value of register~$1$.
The solution is to add extra registers and a function similar to~$r$ that keeps track of which register simulates which register.

\begin{lemma}[TOPL to RA]\label{lemma:topl-to-ra}
There exists an algorithm that, given a TOPL automaton~${\cal A}$, builds a register automaton~${\cal A}'$ such that ${\cal L}({\cal A}')=f({\cal L}({\cal A}))$, where $f\bigl((v_1,\ldots,v_n)\bigr)=v_1\ldots v_n$ extends to languages as follows
\begin{align*}
f({\cal L}({\cal A})) = \{\,f(v_1)\ldots f(v_k)\mid v_1\ldots v_k\in{\cal L}({\cal A})\,\}
\end{align*}
If $\cal A$~has $m$~registers, $|Q|$~states, $|\delta|$~transitions, and works over $n$-tuples, then ${\cal A}'$~has $2m+1$ registers, $O(?)$~states, and $O(?)$~transitions.
\end{lemma}
\begin{proof}
Each state~$q$ of~${\cal A}$ is encoded by $(2m)^m$ states $(q,r)$ of~${\cal A}'$, one for each $r\in[m]\to[2m]$.
While in a state~$(q, r)$, register~$r(i)$ of~${\cal A}'$ simulates register~$i$ of~${\cal A}$.
Each transition $(q,(g,a),q')$ in~${\cal A}$ is encoded by paths
\begin{align*}
(q_0,r_0)\xrightarrow{(g_1,a_1)}(q_1,r_1)\xrightarrow{(g_2,a_2)}\cdots\xrightarrow{(g_n,a_n)}(q_n,r_n)
\end{align*}
with $q_0=q$ and $q_n=q'$.
For each~$r_0$ there are at most $(2m+1)^n$ such paths, because each $(q_j,r_j)$ has at most $2m+1$ successors, as described below.

The following invariants are maintained along the path.
The values held by registers~$r_0([m])$ are not changed -- they simulate the values that ${\cal A}$~holds in state~$q$.
The guards~$g_j$ use only the current letter and the registers~$r_0([m])$.
The values held by registers~$r_n([m])$ in state~$(q_n,r_n)$ are the values that ${\cal A}$~holds in state~$q'$.
In intermediate states~$(q_j,r_j)$, the registers~$r_j([m])$ hold a mixture of the values held by~$r_0([m])$ and those held by~$r_n([m])$ in state~$(q_n,r_n)$.
A more precise description of the mixture follows:
Let the action~$a_{(\le j)}$ be obtained from the original action~$a$ by filtering out assignments $({\sf set}\,i':=j')$ with $j<j'$.
Then registers~$r_j([m])$ in state~$(q_j,r_j)$ simulate what the registers of~${\cal A}$ would be in state~$q'$ if $a$ would be replaced by~$a_{(\le j)}$.

\smallskip
The invariants mentioned in the previous paragraph are maintained by constructing the guards~$g_j$ and the actions~$a_j$ as follows.

Let $I_g$ be the set $\{\,i\mid\text{${\sf eq}\,i=j$ occurs in~$g$}\,\}$ of registers that must equal the current component~$j$; similarly, let $I'_g=\{\,i\mid\text{${\sf neq}\,i\ne j$ occurs in~$g$}\,\}$.
If $|r_0(I_g)|\ge2$ or $|r_0(I_g)\cap r_0(I'_g)|\ge1$, then $(q_{j-1},r_{j-1})$~has no successor.
If $r_0(I_g)=\{i\}$, then $(q_{j-1},r_{j-1})$ has exactly one successor, and the guard~$g_j$ is ${\sf eq}\,i$.
If $r_0(I_g)=\emptyset$, then $(q_{j-1},r_{j-1})$ has $|[2m]-r_0(I'_g)|+1$ successors with the guards {\sf fresh} and, respectively, ${\sf eq}\,i$ for $i\in[2m]-r_0(I'_g)$.

The action~$a_j$ and the function~$r_j$ are computed from the original action~$a$, the previous function~$r_{j-1}$, and from the guard~$g_j$, which is described in the previous paragraph.
Let $I_a=\{\,i\mid\text{$a$~writes component~$j$ to register~$i$}\,\}$.
\rg{Introduce a normalize operation on acitons when they are defined.}
First a target register in~${\cal A}'$ is picked, and then the saving of component~$j$ in registers~$I_a$ is simulated.
The target~$k\in[2m]$, which is needed only if $I_a\ne\emptyset$, is picked as follows:
\begin{align*}
k=\begin{cases}
i &\text{if $g_j$ is ${\sf eq}\,i$} \\
\min \bigl([2m]-r_0([m])-r_{j-1}([m]-I_a)\bigr) &\text{if $g_j$ is {\sf fresh}}
\end{cases}
\end{align*}
The action~$a_j$ depends on~$g_j$ and on~$I_a$.
\begin{align*}
a_j=\begin{cases}
  {\sf nop} &\text{if $g_j$ is ${\sf eq}\,i$, or $I_a=\emptyset$} \\
  {\sf set}\,k &\text{if $g_j$ is {\sf fresh}, and $I_a\ne\emptyset$}
\end{cases}
\end{align*}
Finally, the repartition function is updated to reflect that registers~$I_a$ are now simulated by~$k$.
\begin{align*}
r_j(i) =\begin{cases}
  k &\text{if $i\in I_a$} \\
  r_{j-1}(i) &\text{if $i\notin I_a$}
\end{cases}
\end{align*}

At this point the labels have the form $({\sf eq}\,i,{\sf nop})$ or $({\sf fresh},{\sf set}\,i)$ or $({\sf fresh},{\sf nop})$.
Only the latter is disallowed by the definition of register automata.
It can be handled by adding one register, without significantly increasing the number of transitions.
First, each label $({\sf fresh},{\sf nop})$ is transformed into $({\sf fresh},{\sf set}\,2m+1)$.
Second, for each transition labeled $({\sf fresh},a)$, we add a parallel transition labeled $({\sf eq}\,2m+1,a)$.
\end{proof}

\begin{remark}
It follows from \autoref{lemma:ra-to-topl} and \autoref{lemma:topl-to-ra} that simple TOPL automata and register automata are equally expressive.
\end{remark}

%>>>
\subsection{Automata with Rollback and Skip} %<<<

TOPL automata are almost convenient for runtime verification of Java.
The letters will be events like method calls and returns.
Calls and returns happen, strictly speaking, at different moments.
Moreover, some properties might explicitly mention other events that must happen between a call and its corresponding return.
But, consider the constraint that iterators should advance only if {\tt hasNext} returned {\tt true}.
The event `{\tt hasNext} was called on the iterator that is being tracked' and the event `{\tt hasNext} returned {\tt true}' are distinct.
Yet, it is convenient to pretend that two such consecutive events make one composed event.
This motivates rollback, a mechanism by which transitions consume multiple consecutive letters.

\begin{definition}\label{def:rollback}
A \emph{rollback automaton}~${\cal A}$ consists of:
\begin{itemize}
\item a finite set~$Q$ of states; an initial state $q_0\in Q$; an initial store $s_0\in S$; a set $F\subseteq Q$ of final states
\item a finite transition relation $\delta\subseteq Q\times\Lambda^*\times Q$
\end{itemize}
where $\Lambda$ is a set of labels as defined in \autoref{sec:overview}.
\end{definition}

The difference between rollback automata and (simple) automata, according to definitions \ref{def:automaton}~and~\ref{def:rollback}, is that rollback transitions have a list of labels $\bar\lambda=\lambda_1\ldots\lambda_d$, while simple transitions have exactly one label~$\lambda$.
A transition with exactly one label is said to be a \emph{unit transition}.
If a rollback automaton has only unit transitions, then it is also a (simple) automaton.

The semantics of a rollback automaton cannot be described by the configuration graph from \autoref{def:cgraph}, because that definition does not handle non-unit transitions.
Instead, we define a rollback configuration graph.
Perhaps surprisingly, in the case of simple automata, the rollback configuration graph does not coincide with the configuration graph.
This discrepancy is explained by the different goals of the two models: automata without rollback are meant to be easy to analyze, while rollback automata are meant to be convenient for specifying properties of object-oriented programs.
Often the desired behavior for a letter is to remain in the same configuration.
Without rollback, this behavior is achieved by explicit loops in the automaton.
The definition of the rollback configuration graph reduces the need to explicitly list such skip loops.

A \emph{rollback configuration} is a pair~$(x,w)$ of a configuration~$x$ and a word~$w$;
we denote the set of rollback configurations by $Y=X\times\Sigma^*$.
We think of $w$ as yet to be processed.
A rollback configuration is \emph{initial} when its configuration is the initial configuration; that is, it has the shape $\bigl((q_0,s_0),w\bigr)$, where $q_0$~is the initial state of the automaton, and $s_0$~is the initial store of the automaton.
A rollback configuration is \emph{final} when its state is final and its word is the empty word; that is, it has the shape $\bigl((q,s),\epsilon\bigr)$, where $q$~is one of the final states~$F$ of the automaton, and $\epsilon$~is the empty word.
The rollback configuration graph is a subset of $Y\times\Sigma^*\times Y$.
We write \[ y_1 \stackrel w\hookrightarrow_{\cal A} y_2\] to mean that $(y_1,w,y_2)$ is in the rollback configuration graph of~${\cal A}$.
If the automaton is clear from the context, we omit the subscript.

The following concepts simplify the definition of the rollback configuration graph.
The (simple) automaton \[{\cal T}\bigl(s_0;(g_1,a_1),\ldots,(g_d,a_d)\bigr)\] is defined to have states $0$,~$1$, \dots,~$d$, out of which $0$~is initial and $d$~is final, transitions $\bigl(i-1,(g_i,a_i),i\bigr)$ for all $i\in[d]$, and initial store~$s_0$.
Recall that $\ell_1\ldots\ell_k\in{\cal L}({\cal A})$ when there exist (not necessarily distinct) configurations $x_0$,~$x_1$, \dots,~$x_k$ such that $x_0$~is the initial configuration, $x_k$~is a final configuration, and \[x_{i-1}\stackrel{\ell_i}\to_{\cal A}x_i\qquad\text{for $i\in[k]$}\]
When the store of~$x_k$ is~$s_k$ we say that \emph{${\cal A}$ can accept $\ell_1\ldots\ell_k$ with store~$s_k$}.
A word may be accepted with multiple stores.

\begin{definition}\label{def:rcg}
The \emph{rollback configuration graph} of an automaton consists of two types of transitions:
\begin{enumerate}
\item \emph{rollback transitions}
  \[\bigl((q_1,s_1),ww'\bigr)\stackrel w\hookrightarrow\bigl((q_2,s_2),w'\bigr)\]
when there exists a transition $(q_1,\bar\lambda,q_2)\in\delta$ such that ${\cal T}(s_1;\bar\lambda)$ can accept $w$ with store~$s_2$
\item \emph{skip transitions}
  \[(x,\ell w)\stackrel\ell\hookrightarrow(x,w)\]
when no rollback transition starts from $(x,\ell w)$
\end{enumerate}
\end{definition}

The \emph{rollback language}~${\cal L}_\rho({\cal A})$ of an automaton~${\cal A}$ is the set of words that label walks from some initial rollback configuration to some final rollback configuration:
\[
{\cal L}_\rho({\cal A})=
  \{\,w_1\ldots w_k\mid
    \text{$y_0$~initial,
    $y_{i-1}\stackrel{w_i}\hookrightarrow y_i$ for $i\in[k]$,
    $y_k$~final}\,\}
\]
Since a simple automaton~${\cal A}$ is also a rollback automaton, is has both a simple language~${\cal L}({\cal A})$ and a rollback language~${\cal L}_\rho({\cal A})$.
The treatment of skip transitions implies the aforementioned
discrepancy, that the languages ${\cal L}({\cal A})$ and ${\cal L}_\rho({\cal A})$ are usually distinct.

\begin{example}
Consider the automaton consisting of one transition labeled with the guard ${\sf eq}\,1$, from the initial state to the final state.
The alphabet is $\Sigma=V$ and the initial store has one register containing value~$v$.
The simple language of this automaton consists of one word made of one letter, namely~$v$.
The rollback language, on the other hand, consists of all words that contain the letter~$v$.
\eoe
\end{example}

It is possible, however, to transform TOPL automata such that their rollback languages coincide with their simple languages.

\begin{lemma}[TOPL to rTOPL]\label{lemma:topl-to-rtopl}
There exists an algorithm that, given a TOPL automaton~${\cal A}$ with $|Q|$~states, at most $d$~transitions outgoing of each state, and guards with at most $k$~conjuncts, builds a TOPL automaton~${\cal A}'$ with $|Q|+1$ states and at most $(d+k^d)|Q|$ transitions such that
\[ w\in{\cal L}({\cal A}) \iff w\in{\cal L}_\rho({\cal A}')\]
\end{lemma}
\begin{proof}
For the simple automaton~${\cal A}$ compare the simple configuration graph with the rollback configuration graph.
Each simple transition $x_1\to^\ell x_2$ corresponds to several rollback transitions $ (x_1,\ell w)\hookrightarrow^\ell (x_2,w)$, for all $w$.
The rollback graph, however, also has skip transitions $(x,\ell w)\hookrightarrow^\ell (x,w)$ for configurations~$x$ that have no outgoing rollback transitions.
Thus, the simple language and the rollback language would agree if all simple configurations would have at least one outgoing simple transition.

We obtain ${\cal A}'$ from~${\cal A}$ by adding unit transitions that do not change the simple language, but ensure that all simple configurations have an outgoing transition.
First we add a special stuck state~$q_{\rm stuck}$.
Then, for each original state~$q$, we list the guards $g_1$,~$g_2$, \dots,~$g_d$ of the outgoing transitions.
The configuration $(q,s)$ has no outgoing transition for some~$\ell$ when $(s,\ell)\not\models g_i$ for $i\in[k]$.
So, we synthesize a guard~$g$ that holds exactly in this situation.
Informally, we want to add a transition from~$q$ to~$q_{\rm stuck}$ with the guard $g=\lnot g_1\land\ldots\land\lnot g_d$ and the action ${\sf nop}$.
There is one small complication: $G_{\rm TOPL}$ does not have a negation operator.
However, we can negate the simple guards ${\sf eq}$ and ${\sf neq}$, we can use distributivity to put $g$ in disjunctive normal form, and we can simulate disjunction by parallel transitions.
Thus, if each $g_i$ contains up to $k$ simple conjuncts, we add at most $k^d$ transitions from state~$q$.
\end{proof}

The converse transformation is more difficult.
There are many obvious ways to simulate a rollback TOPL automaton with a simple TOPL automaton, and many of them are wrong.
Note, for example, that when the set~$V$ of values is countable, the simple configurations are countable, but the rollback configurations are uncountable.
Rollback, which ensures that several letters occur atomically, and skip, which filters irrelevant letters, usually lead to intuitive behaviors, but not always, as the following example illustrates.

\begin{example}
Consider the following rollback TOPL automaton with $2$~registers over the alphabet $\Sigma=V=\{A,B\}$:
\begin{itemize}
\item $Q=\{1,2,3\}$ and $q_0=1$ and $s_0=(A,B)$ and $F=\{3\}$
\item $\delta$ consists of $\bigl(1,\bigl[({\sf eq}\,2,{\sf nop}),({\sf eq}\,1,{\sf nop}),({\sf eq}\,2,{\sf nop})\bigr],2\bigr)$ and $\bigl(1,\bigl[({\sf eq}\,1, {\sf nop})\bigr],3\bigr)$
\end{itemize}
The rollback language of this is automaton consists of those words in which the first $A$ is not surrounded by two $B$s.
For example it contains $A$, $BA$, $BAA$, and $BAAB$, but not $BAB$ or~$BBAB$.
\eoe
\end{example}

 The key idea for encoding rollback TOPL automata into simple TOPL automata is the following:
\emquote{It is sufficient to simulate rollback configurations with words shorter than the length~$d$ of the longest transition, because both rollback and skip transitions depend on $\le d$~letters.}
If $|w|<d$, it should be possible to encode a rollback configuration $((q,s),w)$ using the finite memory of a simple TOPL automaton.
To decide which transitions to take we have $|w|+1$ letters, the ones stored in the current configuration plus the current letter, and $m$~registers to consider.
If $|w|+1<d$, then the current letter~$\ell$ is simply stored in the current configuration, and we move to (the encoding of) $((q,s),w\ell)$.
Eventually, $d$~letters are available and all transitions outgoing from~$q$ can be evaluated.
The original guards involve comparing letter components with register values.
Now some of the letter components are themselves in registers, and TOPL automata do not have guards that compare registers.
But, we can ensure that the stores are injective (as in the translation from TOPL automata to register automata) and then the information about which registers equal which registers is statically available.
Actions simply translate to substitutions into latter guards on the same transition.

\begin{lemma}[rTOPL to TOPL]\label{lemma:rtopl-to-topl}
There exists an algorithm that, given a rollback TOPL automaton~${\cal A}_\rho$, builds a simple TOPL automaton~${\cal A}$ such that
$ {\cal L}_\rho({\cal A}_\rho) = {\cal L}({\cal A})$.

If ${\cal A}_\rho$ is over the alphabet~$V_\rho^n$ with $m_\rho$~registers, $|Q_\rho|$~states, and $|\delta_\rho|$~transitions of length~$\le d$,
then ${\cal A}$ is over the alphabet $V_\rho$ with $m=m_\rho+(d-1)n$ registers, $O(d^2 (m+1)^m|Q_\rho|)$ states, and $O(d^2 (m+1)^{(m+n)}|\delta_\rho|)$ transitions.
\end{lemma}
\begin{proof}
The set of states of~${\cal A}$ is \[Q=Q_\rho\times\{0,\ldots,d-1\}\times\{0,\ldots,d-1\}\times\bigl([m]\pmap[m]\bigr)\]
When the rollback configuration
\[ \bigl(q_\rho,(v_1,\ldots,v_{m_\rho})\bigr),\ell_0\ldots\ell_{h-1}\]
of~${\cal A}_\rho$ is reached, one of the simple configurations
\[ (q_\rho,h,k,r),\;(u_1,\ldots,u_m) \]
of~${\cal A}$ is reached.
Here $h$~is the length of the remembered history, while $k$,~$r$, $u_1$, \dots,~$u_m$ vary subject to the following constraining invariants:
\begin{itemize}
\item the stores of~${\cal A}$ are injective: $u_i \ne u_j$ if $i\ne j$
\item for $i\in[m_\rho]$, the value of register~$i$ of~${\cal A}_\rho$ is stored in register $r(i)$ of~${\cal A}$; that is, $ u_{r(i)} = v_i $
\item for $0\le k'<h$ and $\ell_{k'}=(v'_1,\ldots,v'_n)$ and $1\le i'\le n$, the $i'$th component~$v'_{i'}$ of letter~$\ell_{k'}$ is stored in register $r(\iota(k+k',i'))$ of~${\cal A}$, where $\iota(k'',i')=m_\rho+(k''\bmod d)n+i'$; that is,
  \[u_{r(\iota(k+k',i'))}=v'_{i'}\]
\item $r$ is undefined for register slots that are reserved for storing letters but are currently unused; namely, $r(\iota(k+k',i'))$ is undefined for all $i'$~and~$k'$ such that $1\le i'\le n$ and $h\le k'<d$
\end{itemize}

\smallskip
We consider in turn each state $q=(q_\rho,h,k,r)$.
Its outgoing transitions are determined by the outgoing transitions of~$q_\rho$.

We must cater for two situtaions: Either more letters are arriving and
we should simulate storing them in the queue and possibly make a state
transition, or no more letters are arriving and we should simulate
emptying the queue to see if we end up in an accepting state.

Crucially, enough information is available to statically simulate receiving all the letters in the queue.
To see this, consider a transition in ${\cal A}_\rho$ out of ~$q_\rho$,
\[ (q_\rho, [(g_0,a_0),\ldots,(g_{d'-1},a_{d'-1})], q'_\rho)
  \qquad\text{with $d'\leq h$} \]
We can assume $d'\leq h$ as only transitions short enough to be
evaluated with the received letters may be taken.

Consider an assignment $({\sf set}\,i:=j)$ that appears in~$a_{k'}$.
Suppose that the distribution of values just before this assignment is given by~$r'$.
This means that the register~$i$ of~${\cal A}_\rho$ is simulated by $r'(i)$, and that the $j$th component of letter~$\ell_{k'}$ is simulated by $r'(\iota(k+k',j))$.
After the assignment is executed, the distribution of values is given by
\[r''(i') = \begin{cases}
  r'(\iota(k+k',j)) & \text{if $i'=i$} \\
  r'(i') & \text{otherwise}
\end{cases}\]
Thus, it is possible to statically find the register distribution function after
each of the $d'$~steps.

Let us write $r_{k'}$ for the distribution function just before step~$k'$; in particular, $r_0=r$, where $r$~is given by the state~$q$ of~${\cal A}$.
Suppose now that $g_{k'}$ contains the conjunct $({\sf eq}\,i=j)$.
We can evaluate this conjunct statically by checking whether $r_{k'}(i)=r_{k'}(\iota(k+k',j))$.
Similarly, we can evaluate $({\sf neq}\,i\ne j)$ by checking whether $r_{k'}(i)\ne r_{k'}(\iota(k+k',j))$ as the store is injective.
Thus we can evaluate all guards $g_0$,~$g_1$, \dots,~$g_{d'-1}$.

If one of the guards is not true, we know that the transition would
not be taken, if the queue were to be emptied. If all guards are true,
we know that the resulting state is $(q'\rho, h-d',( k+d')\bmod
d,r_{d'})$.
If $h-d' > 0$ then we carry on simulating. If $h-d' = 0$ then we note
if $q'_\rho$ is final in ${\cal A}_\rho$.

If we find that no transitions are taken, then we must compute the
result of a skip transition. This can also be done statically by
incrementing~$k$, decrementing~$h$ and
 replacing the distribution function by one that is undefined at
 $\iota(k,i')$ for $i'\in[n]$. If $k-1 > 0$, we carry on simulating and
 if $k-1 = 0$, we note
if $q_\rho$ is final in ${\cal A}_\rho$.

 If any of these simulations thus notices a final state,
then $(q_\rho, h, k, r)$ is final in ${\cal A}$.

Now to handle the case of more incoming letters, we need to add transtions.
We treat three cases: Firstly, if the queue is not full ($h < d-1$) then we
simply store the current letter in the queue. Secondly, if the queue
is full ($h=d-1$) and
none of the transitions in ${\cal A}_\rho$ out of $q_\rho$ has maximal
length (length $d$), then we can statically determine if we need to simulate a
rollback transition or a skip transition and what the resulting states
would be. Thirdly, if the queue is full, and there is a transition of
maximal length, then we need to dynamically look at the current letter
to determine if that transition is taken and where it leads. Note
that this also determines whether a skip transition should be simulated.

{\it Case $h<d-1$}.
In this case all outgoing transitions of~$q$ simply record the current letter $\ell=(v_1,\ldots,v_n)$.
To maintain the injectivity of stores, only those components of~$\ell$ that are not already in some register must be stored.
We consider $(m+1)^n$ distinct situations: each of the $n$~components may be in one of the $m$~registers, or it may be fresh.
Such a situation is described by a function $p\in[n]\pmap[m]$.
We add to~${\cal A}$ a transition
\[ (q_\rho,h,k,r),\;(g_p,a_p),\;(q_\rho,h+1,k,r_p)\]
The guard~$g_p$ is constructed such that it ensures we are indeed in a situation described by~$p$; the action~$a_p$ stores the fresh values of~$\ell$ somewhere outside of $r([m])$; the function~$r_p$ records where the fresh values were stored and where the existing values already were.

The guard $g_p$ is constructed as follows.
If $p(j)$ is undefined, which means that $v_j$ should be fresh, then $g_p$ contains conjuncts $({\sf neq}\,i\ne j)$ for $i\in[m]$.
If $p(j)$ is defined, which means that $u_{p(j)}=v_j$, then $g_p$ contains the conjunct $({\sf eq}\,p(j)=j)$.
These are all the conjuncts of~$g_p$.

We now fix some injection $\sigma$ from the set $\{v_j\mid\text{$p(j)$ undefined}\}$ of fresh values to the set $[m]-r([m])$ of unused registers.
The action $a_p$ contains an assignment $({\sf set}\,\sigma(v_j):=j)$ for each $j$ where $p(j)$~is undefined.
Also
\[ r_p(\iota(k',i')) = \begin{cases}
  p(i')  & \text{if $k'=k+h$ and $p(i')$ defined} \\
  \sigma(v_{i'}) & \text{if $k'=k+h$ and $p(i')$ undefined} \\
  r(\iota(k',i')) &\text{otherwise}
\end{cases}\]

{\it Case $h=d-1$, no outgoing transitions of length $d$}.
At this point the values in the $m$~registers of~${\cal A}$ are enough
to decide whether to simulate a rollback or a skip transition
of~${\cal A}_\rho$.
The construction above is used to add transitions which save the
current letter. However, each such transition is added a number of
times, one for each outgoing transition in ${\cal A}_\rho$. The
targets of these transitions are modified to reflect the effect of
taking the transition. This can be determined statically as described
above. Specifically, it is known at this point if any of the transitions
can be taken. We only add the ones that would (we cannot determine a
target for the others anyway). If no transitions can be taken, we
simulate a rollback transition. This is again done by storing the
current letter, but we also drop the letter at the front of the queue
(by incrementing~$k$ and decrementing~$h$ and
 replacing the distribution function by one that is undefined at $\iota(k,i')$ for $i'\in[n]$).

{\it Case $h=d-1$, ${\cal A}_\rho$ has an outgoing transition of length $d$}.
At this point the values in the $m$~registers of~${\cal A}$ together
with the current letter are needed to decide whether to simulate a
rollback or a skip transition of~${\cal A}_\rho$.

As in the case above, we can statically evaluate all transitions of
length shorter than $d$ and add transitions for them. But we cannot
add the encoding of a skip transition because it should only be taken
if no rollback transitions are. For each rollback transition of length
$d$
\[ (q_\rho, [(g_0,a_0),\ldots,(g_{d-1},a_{d-1})], q'_\rho), \]
we can statically evaluate up to the point right before the final
guard $g_{d-1}$. Thus we can add an automata transition to ${\cal A}$
with $(g'_{d-1}, a'_{d-1})$ on it and target $(q'_\rho, 0, 0, r')$, where
$g'_{d-1}$ and $a'_{d-1}$ are versions of $g_{d-1}$ and $a_{d-1}$
modified to refer to $r_{d-1}$ and $r'$ is a version of $r_d$ which is
undefined on all indices pointing into the queue.

The guard $g'_{d'-1}$ is constructed as follows:
For all conjuncts ${\sf eq}\,i=j$ in $g_{d'-1}$, $g'_{d'-1}$ contains ${\sf eq}\,r_{d'-1}(i)=j$ and
for all conjuncts ${\sf neq}\,i\ne j$ in $g_{d'-1}$, $g'_{d'-1}$ contains ${\sf neq}\,r_{d'-1}(i)\ne j$.
\rlp{Describe $a'_{d'-1}$?}
%\rlp{Write this as $g_{d'-1}\diamond r_{d'-1}$ and similar for actions?}
% $a'_{d'-1}$ will be described in a moment.

Finally, we must also simulate a skip transition, but only to be taken in case none of the other transitions are.
That is, if any of the short transitions are taken, we have no skip
transition. If none of the short transitions are taken, we construct a
guard that is true if none of the final guards for the maximal length
transitions are. Guards to ensure this are generated using the same
construction employed in the proof of Lemma
\ref{lemma:topl-to-rtopl}. These are then combined with the
construction in the previous case.
\end{proof}

\begin{remark}
It follows from \autoref{lemma:topl-to-rtopl} and \autoref{lemma:rtopl-to-topl} that rollback TOPL automata and simple TOPL automata are equally expressive.
\end{remark}

%>>>
\subsection{Properties} %<<<

The following are consequences of \autoref{th:ra} and Lemmas \ref{lemma:ra-to-topl},~\ref{lemma:topl-to-ra}, \ref{lemma:topl-to-rtopl}, and~\ref{lemma:rtopl-to-topl}.

\begin{theorem}\label{th:main}
Register automata, simple TOPL automata, and rollback TOPL automata share the following properties:
\begin{enumerate}
\item The emptiness and the membership problems are decidable.
\item The language inclusion, the language equivalence, and the universality problems are decidable for $1$~register.
\item The language inclusion, the language equivalence, and the universality problems are undecidable in general.
\item The languages of these automata are closed under union, intersection, concatenation, and Kleene star.
\item The languages of these automata are not closed under complementation.
\end{enumerate}
\end{theorem}

% >>>
% >>>
\section{TOPL Properties}\label{sec:topl} % <<<

In this section, we describe the user level language of TOPL
properties, as well as the translation from TOPL properties to
rollback TOPL automata in \autoref{fig:concepts}.
%
This language provides a user-friendly way to write down certain
rollback TOPL automata.
As such, TOPL properties form a subset of rollback TOPL
automata, and the translation in \autoref{fig:concepts} is morally an
injection. There is, however, in the interest of user-friendliness,
some encoding happening.

Syntactically, a TOPL property has a set of transitions.\footnote{For
  the complete BNF grammar for TOPL we refer to~\cite{our-fool2011}.}
Each transition is a labelled arc (directed edge) with a source and a
target vertex identified by their name.
There must be a vertex named \start and one named \error.
Labels look like method calls.

In the following, we will describe TOPL labels and how they translate to guards
and actions. But first we will describe the events that a TOPL
property considers and hence the alphabet that the corresponding
rollback TOPL automaton works over.

\subsection{The Alphabet}

We model the semantics of programs and properties as sets of event
traces. We say that a program \emph{violates} a property when their sets of traces intersect.
In other words, properties encode bad executions, rather than good executions.

The traces of events that a property $P$ deems lead to a bad execution is thus the language
of the corresponding automaton $\A_P$. Observable events for TOPL properties are method calls
with parameter values and a time-tag. The method name is taken to be a
string literal and an arity (for simplicity we do not distinguish
overloaded methods with the same arity). The time-tag is either $call$ or $ret$,
corresponding to observing the method being called or returned
from. If the time-tag is $ret$, the event carries the return value
rather than any parameter values.

Thus, for $\A_P$, the values of interest come from two
sources; event ids and parameter values: The set $E$ of event ids is given by
the grammar
\[
call\ m^k \mid return\ m^k
\]
where $m^k$ is one of the method names mentioned in $P$ (with arity~$k$).

The set $V_L$ of possible parameter values is the set of values from
the programming language (e.g., Java)
plus a dummy value $\bot$.

The values are then $V = E + V_L$, and the alphabet is $V^{n+2}$,
where $n$ is the maximal arity of a method mentioned in $P$.
(We need one extra register for the return value and one for the event
id.)

We are only concerned with the subset $E \times V_L^{n+1}$, ie the
tuples where exactly the first component is an event
id. If $P$ has a maximal arity of 5, the event $call\ m^3(a, b, c)$
would be understood as $(call\ m^3, \bot,  a, b, c, \bot, \bot)$ by
$\A_P$. Here the first component is the event id, the second is a
filler for the return value, the next three are the parameter values and the rest are
fillers which allows all tuples to have the same lenght. The event $ret\ r = m^3$
would be understood as $(ret\ m^3, r, \bot, \bot, \bot, \bot, \bot)$ by
$\A_P$.

We can now describe the labels of $P$ and explain how they are transformed into guards and
actions of $\A_P$.

\subsection{Guards and Actions from Labels}

Labels refer to the registers via \emph{patterns}. To retain the
flavour of a programming language, we call the registers of $P$
\emph{property variables}.
%
For each property variable \Verb@v@ there are three associated patterns.
The uppercase pattern \Verb@V@ matches any value and writes it in the property variable \Verb@v@.
The lowercase pattern \Verb@v@ reads the value of the property variable \Verb@v@ and only matches that value.
The negated lowercase pattern \Verb@!v@ reads the value of the
property variable \Verb@v@ and only matches different values.

Further, every element of $V$ acts as a pattern that matches only the value it denotes,
and a wildcard~* pattern matches any value.

\smallskip
A TOPL property is \emph{well-formed} when it satisfies the following two conditions:
{\em (i)} labels must contain uppercase value patterns at most once; {\em (ii)}
any use of a lowercase patterns must be preceded by a use of the corresponding uppercase pattern on all paths from \start  (i.e., property variables must be written before being read).
From now on we assume TOPL properties to be well-formed.

A label is of one of three forms:
\[
  l ::=
  call\;m^k(x_1, \ldots, x_k) \mid
  ret\;x := m^k \mid
  x := m^k(x_1, \ldots, x_k)
\]
where $x$ and $x_1, \ldots, x_k$ are all patterns.
The first two forms describe observable events and will be translated
into unit transitions. We describe that translation first and treat
the last form at the end.

In order to match elements from $V$, there is an extra register in
$\A_P$ for each unique element mentioned by $P$ (note that this
includes all the method names). This register contains
that value in the initial state of $\A_P$ and is never overwritten.

For each pattern $x$ which is not *, we define three functions:
$reg(x) : \N$ gives the associated register, $pred(x) : \N\to G$ gives
the corresponding predicate and, $act(x) : \N\to A$ gives the action, i.e.
\[
\begin{array}{l l l}
  x & pred(x)(j) & act(x)(j) \\
  \hline
  \mathtt{V} & {\sf true} & {\sf set}\,{\it reg}({\tt v}):=j \\
  \mathtt{v} & {\sf eq}\,reg(\mathtt{v})=j & {\sf nop} \\
  \mathtt{!v} & {\sf neq}\,reg(\mathtt{v})=j  & {\sf nop}  \\
  a\in V & {\sf eq}\,reg(a)=j  & {\sf nop}  \\
  * & {\sf true} & {\sf nop}  \\
\end{array}
\]
We can now interpret labels.
\newcommand{\den}[1]{[\![#1]\!]}
\newcommand{\denG}[1]{\den{#1}_G}
\newcommand{\denA}[1]{\den{#1}_A}
For a label $l$, we define
\[
\den{l} = [(\denG{l}, \denA{l})]
\]
where $\denG-$ is given by
\[
\begin{array}{l l}
  l & \denG l \\
  \hline
  call\;m^k(x_1, \ldots, x_k) & pred(m^k)(1) \\
                                           & \land\,pred(x_1)(3) \land\ldots\land pred(x_k)(k+2) \\
  ret\;x := m^k & pred(m^k)(1) \land {\sf eq}\,reg(x) = 2 \\
\end{array}
\]
and $\denA-$ is given by
\[
\begin{array}{l l l}
  l & \denA l \\
  \hline
  call\;m^k(x_1, \ldots, x_k) & act(x_1)(3); \dots; act(x_k)(k+2) \\
  ret\;x := m^k & act(x)(2) \\
\end{array}
\]
If $P$ is well-formed all the writes will be to different registers
and thus commute.

Let us now consider the third label
\[
x := m^k(x_1, \ldots, x_k)
\]
Notice how the right hand side refers to call time, while the left
hand side refers to return time. We decided that this label should
mean that $m^k$ was called with parameters matching $x_1, \ldots, x_k$
and returned a value matching $x$, \emph{and no event was observed in
  the meantime}. This is because an intermediate call, for instance a
recursive call, could disconnect the method call and the return value.
This label makes use of the rollback feature and translates to a
transition of depth two:
\[
\den{x := m^k(x_1, \ldots, x_k)}
=
[\den{call\;m^k(x_1, \ldots, x_k)}, \den{ret\;x := m^k}]
\]

\paragraph{Initial State.}
All that remains is to describe the initial state of $\A_P$.
As mentioned, the registers which corresponds to values in $V$
contain those values in the initial state. Note that the generated
actions never overwrite these registers. Registers which correspond
to property variables contain $\bot$. If $P$ is well-formed, $\bot$
will never be read from those registers.

\paragraph{Directives.}
To ease the task of writing TOPL properties and to increase their
usefulness, two directives were added to the language. A \texttt{prefix}
directive for convenience when specifying method names and an
\texttt{observe} directive for pre-filtering events.
%
The prefix directive $\mathtt{prefix}\; p$ produces from every
method name pattern $m^k$, an extra method pattern $pm^k$. It further
produces, from any transition involving $m^k$, a similar transition
involving $pm^k$.
%
The prefix directive $\mathtt{observe}\; p$ has the effect that only
method calls which matches $p$ are considered part of the event trace.

% >>>
\section{Examples} \label{sec:examples} % <<<

In this section, we formalize some temporal properties in TOPL. We refer the reader to ~\cite{our-fool2011} for a more comprehensive
exemplification of properties.

\paragraph{Iterators.}
Property~\eqref{q:concur-it} in
Section~\ref{sec:motivating-examples} can be formalized as follows:
{\small
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
 property InvalidateOtherIterators
   observe <java.util.\{Collection,Iterator\}.*>
   prefix <java.util.\{Collection,Iterator\}>
   start -> start: *
   start -> one:  \pattern{X} := \pattern{C}.iterator()
   one -> one:    *
   one -> two:    \pattern{Y} := \pattern{c}.iterator()
   two -> yBad:   \pattern{x}.remove()
   two -> xBad:   \pattern{y}.remove()
   yBad -> error: call \pattern{y}.*[*]
   xBad -> error: call \pattern{x}.*[*]
\end{Verbatim}
\delimitVerbatim}%
This property describes the interaction of three objects.
The first line is an \texttt{observe} directive declaring that we are
interested in all method calls (denoted by the wild card *) on
instances of \Verb@java.util.Collection@ and \Verb@java.util.Iterator@ \emph{and} all those that override them.
\autoref{fig:first.topl} shows a graphical representation of the
property.
%
\begin{figure}[t]\centering
\begin{tikzpicture}
  \def\x{2.3}
  \def\y{1.2}
  \tikzset{vertex/.style={draw,circle,inner sep=1pt}}
  \tikzset{transition/.style={->,>=latex}}
  \tikzset{every label/.style={gray}}
  \node[vertex] (start) at (0,0) [label=left:\texttt{start}] {};
  \node[vertex] (one) at (0,-1*\y) [label=left:\texttt{one}] {};
  \node[vertex] (two) at (0,-2*\y) [label=below:\texttt{two}] {};
  \node[vertex] (xBad) at (1*\x,-2.5*\y) [label=right:\texttt{xBad}] {};
  \node[vertex] (yBad) at (-1*\x,-2.5*\y) [label=left:\texttt{yBad}] {};
  \node[vertex,fill=darkred] (error) at (0,-3*\y) [label=below:\textcolor{darkred}{\texttt{error}}] {};
  \draw[transition] (0,0.5)--(start);
  \draw[transition] (start)--node[right]{$\pattern X:=\pattern C.\mathtt{iterator}()$} (one);
  \draw[transition] (start) .. controls +(30:1cm) and +(-30:1cm) .. node[right]{$*$} (start);
  \draw[transition] (one) .. controls +(30:1cm) and +(-30:1cm) .. node[right]{$*$} (one);
  \draw[transition] (one)--node[right]{$\pattern Y:=\pattern c.\mathtt{iterator}()$} (two);
  \draw[transition] (two) -- node[sloped,above]{$\pattern y.\mathtt{remove}()$} (xBad);
  \draw[transition] (two)--node[sloped,above]{$\pattern x.\mathtt{remove}()$} (yBad);
  \draw[transition] (xBad)--node[sloped,below]{$\mathtt{call}\;\pattern x.{*}[*]$} (error);
  \draw[transition] (yBad)--node[sloped,below]{$\mathtt{call}\;\pattern y.{*}[*]$} (error);
\end{tikzpicture}
\caption{Property {\tt InvalidateOtherIterators}}
\label{fig:first.topl}
\end{figure}
\paragraph{Heap Shape and Values Sensitive Properties}  % <<<
The following is a TOPL encoding of the property~\eqref{q:concur-it4} in Section~\ref{sec:motivating-examples}.
It reports an error if a list is cyclic or it has the pan-handle shape (i.e.,
there is a lasso at some point). Directives are omitted.
%
{\small
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
 property ListNotCyclic
   start -> start: *
   start -> a: \pattern{X} := *.getList()
   a -> a:     \pattern{X} := x.next()
   a -> b:     \pattern{Y} := x.next()
   b -> b:     \pattern{Y} := y.next()
   b -> error: x := y.next()
   a -> error: x := x.next()
\end{Verbatim}
\delimitVerbatim}%
The idea is that this property will bind the property variable $x$ with any possible object in the list, and the $y$ with any possible successors (via the next field) of the current binding of $x$.
Therefore, if there is a lasso, in the list, this will be detected when a new binding of $y$ via a \texttt{b -> b} becomes equal to the binding of $x$.
The transition \texttt{a ->error} detects the case where there is an object pointing to itself. This property shows the importance of re-binding for specification variables. This phenomenon is also shown by  the following property which detects when a dictionary overwrite one of its bindings.
{\small
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
 property BadDictionary
   message "dictionary overwrites its bindings"
   observe <Dictionary.*>
   prefix <Dictionary>
   start -> start: *
   start -> written:   \pattern{D}.put(\pattern{K}, \pattern{V})
   written -> written: d.put(k, \pattern{V})
   written -> error:   !v := d.get(k)
\end{Verbatim}
\delimitVerbatim}%
The overwrite is detected by the guard which checks if the value associated with a key $k$ is the same as the original binding recorded in the property variable $v$.

%>>>
\paragraph{Iterating Ropes Data Structures.} % <<<
The property~\eqref{q:concur-it2} from Section~\ref{sec:motivating-examples} can be encoded in TOPL as follows:
%
{\small
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
 property IterateRopes
   observe <{Itr.next,Concat.make,Str.itr}>
   prefix <{Itr,Concat,Str}>
   start -> start: *
   start -> a:  \pattern{I} := \pattern{S}.itr()
   a -> a: *, \pattern{S} := make(\pattern{s}, *), \pattern{S} := make(*, \pattern{s})
   a -> b: \pattern{J} := \pattern{s}.itr()
   b -> c: \pattern{i}.set(*)
   c -> error: \pattern{j}.next()
   b -> d: \pattern{j}.set(*)
   d -> error: \pattern{i}.next()
\end{Verbatim}
\delimitVerbatim}%
The re-binding in the self-loop {\tt a -> a} combined with {\tt a->a: *} ensure that iterators of sub-collections in the rope are tracked. Therefore,
of two different iterators of two collections sharing some object invalidating `h the error state.
\\dd{are there other permutation missed by the property?}

%>>>
\paragraph{Property for Taint Info.} % <<<
To check taint information as described by property~\eqref{q:concur-it3} in Section~\ref{sec:motivating-examples} we can use the following
TOPL specification:
{\small
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
 property TaintCheck
   observe <{Itr.next,Concat.make,Str.itr}>
   prefix <{Itr,Concat,Str}>
   start -> start: *
   start -> a:  \pattern{X} := input()
   a -> a: \pattern{X} := make(\pattern{x}, *), \pattern{X} := make(*, \pattern{x}), (!sani)(*)
   a -> b: sani(\pattern{x})
   a -> error: sink(\pattern{x})
\end{Verbatim}
\delimitVerbatim}%
The specification takes care to track  any tainted substring $x$ used in the rope and report an error if $x$ reaches the sink method.

\paragraph{Singleton Pattern.}
The last property we present concerns
the singleton pattern where the instantiation of a class is restricted to one object. It is used when exactly one object is needed to coordinate actions across the system. It can be enforced by the following.
{\small
\delimitVerbatim
\begin{Verbatim}[commandchars=\\\{\}]
 property SingletonPattern
   start -> a:  \pattern{I} := getInstance()
   a -> error:  !\pattern{i}:= getInstance()
\end{Verbatim}
\delimitVerbatim}%
The property produce an error is the object obtained by the method {\tt getInstance()} is not the same as the one already bound to the automata variable $i$.

% >>>
% >>>
\section{Relation to Trace Slicing} \label{sec:slicing} % <<<

Papers on runtime verification describe alternative methods to cope with infinite alphabets.
In particular, Ro\comma{s}u and~Chen~\cite{dblp:journals/corr/abs-1112-5761} describe a formal model, known as \emph{trace slicing}, that is simple and compelling.
The idea is to slice words over infinite alphabets into words over finite alphabets and then use some formalism that works with finite alphabets, such as a finite automaton.
It is interesting to compare TOPL automata and trace slicing from the point of view of expressivity.

\subsection{Review of Trace Slicing} \label{sec:review_slicing} % <<<

Trace slicing uses the alphabet
\begin{align*}
\Sigma &= C \times \Theta \\
\Theta &= V_\bot^{n-1}
\end{align*}
where $C$ is a finite subset of~$V$.
Each letter~$\ell\in\Sigma$ is a pair~$(c,\theta)$ of a \emph{constant}~$c\in C$ and a \emph{binding}~$\theta\in\Theta$.
Alternatively, a letter is an $n$-tuple $(v_1,\ldots,v_n)$ with $v_1\in C$ and $(v_2,\ldots,v_n)\in \Theta$.
A smaller binding is less specific; it is obtained by replacing some components with~$\bot$.
\begin{align*}
(v_2,v_3,\ldots,v_n)\sqsubseteq(v'_2,v'_3,\ldots,v'_n) \iff
  \text{$v_i\in\{v'_i,\bot\}$ for all $i\in\{2,3,\ldots,n\}$}
\end{align*}
So, bindings are partially ordered.
The corresponding lub (least upper bound) operation $\sqcup$ is defined as usual.

The slice~$w\searrow\theta$ retains the letters with bindings~$\sqsubseteq\theta$.
For words of length~$1$ slicing gives an element of $\Sigma^0\cup\Sigma^1$.
\begin{align*}
(c',\theta')\searrow\theta=\begin{cases}
  (c',\theta') & \text{if $\theta'\sqsubseteq\theta$} \\
  \epsilon & \text{otherwise}
\end{cases}
\end{align*}
Slicing extends pointwise to words of arbitrary length.
Similarly, the projections $\pi_c(c,\theta)=c$ and $\pi_\theta(c,\theta)=\theta$ extend to words of arbitrary length.
\begin{align*}
  \searrow &\in \Sigma^*\times \Theta \to \Sigma^* \\
  \pi_c &\in \Sigma^*\to C^* \\
  \pi_\theta &\in \Sigma^*\to\Theta^*
\end{align*}

\begin{example}\label{ex:slicing}
Let $V$ be the set~$\{1,2,\ldots\,\}$ of positive integers, let $C=[3]$, and let $n=3$.
Then,
\begin{align*}
(1,\bot,\bot)(2,1,\bot)(3,\bot,1)\searrow(1,1)
  &= (1,\bot,\bot)(2,1,\bot)(3,\bot,1) \\
(1,\bot,\bot)(2,1,\bot)(3,\bot,1)\searrow(2,1)
  &= (1,\bot,\bot)(3,\bot,1) \\
(1,\bot,\bot)(2,1,\bot)(3,\bot,1)\searrow(\bot,1)
  &= (1,\bot,\bot)(3,\bot,1) \\
\pi_\theta(1,\bot,\bot)(2,\bot,1) &= (\bot,\bot)(\bot,1) \\
(\bot,\bot)\sqcup(\bot,1) &= (\bot,1) \\
\pi_c(1,\bot,\bot)(3,\bot,1) &= 1\,3
\end{align*}
Note that slicing with different bindings can produce the same result.
\eoe
\end{example}

Each language $L \subseteq C^*$ determines a language ${\cal L}_\sigma(L) \subseteq \Sigma^*$, defined as follows:
\begin{align*}
w \in {\cal L}_\sigma(L)
  \qquad\iff\qquad
\text{$\pi_c(w\searrow\theta)\in L$ for some binding~$\theta$}
\end{align*}
Membership in ${\cal L}_\sigma(L)$ is decidable if membership in~$L$ is decidable.
It is sufficient to enumerate the bindings $\sqcup\pi_\theta(w')$, for all subsequences~$w'$ of~$w$.

\begin{example}\label{ex:slicing_lang}
Let $n=2$, let $C$ be the unit set~$\{1\}$, and let $L$ contain the words of length~$\ge2$ over~$C$.
Then ${\cal L}_\sigma(L)$ is the language of words in which some second component appears twice.
\begin{align*}
{\cal L}_\sigma(L) = \{\,(1,v_1)\ldots(1,v_n)\mid\text{$v_i=v_j$ for some $i$ and $j$}\,\}
\end{align*}
\eoe
\end{example}

% >>>
\subsection{Expressivity}

Registers and slicing are methods to transform recognizers over finite alphabets into recognizers over infinite alphabets.
To compare registers with slicing, a mechanism for finite alphabets must first be fixed.
This section takes that mechanism to be a finite automaton, and compares TOPL automata with slicing applied to regular languages.

Let $n=2$, let $C=\{1\}$, and let $v_1\ldots v_k$ abbreviate the word $(1,v_1)\ldots(1,v_k)$.
The following languages definable by at most one of the two methods, registers and slicing.
\begin{align*}
L_1 &= \{\, v_1\ldots v_k\mid\text{$v_1=v_i$ for some $i\ne1$}\,\} \\
L_2 &= \{\, v_1\ldots v_k\mid\text{$v_1=v_i$ for all $i\ne1$}\,\} \\
L_3 &= \{\, v_1\ldots v_{2k}\mid\text{$v_{2i}=v_{2i+1}$ for $i\ne k$, and $v_1=v_{2k}$}\,\} \\
L_4 &= \{\, v_1\ldots v_k\mid\text{there is a $j$ such that $v_i\ne v_j$ for all $i\ne j$}\,\} \\
L_5 &= \{\, v_1\ldots v_k\mid\text{$v_i\ne v_k$ for all $i\ne k$}\,\}
\end{align*}
Languages $L_1$,~$L_2$, and~$L_3$ are definable by TOPL automata, but not by slicing.
Language $L_4$ is definable by slicing, but not by TOPL automata.
Language $L_5$ is not definable by TOPL automata or by slicing.

Each word~$w$ has a set of slice projections $\{\,\pi_c(w\searrow\theta)\mid\theta\in\Theta\,\}$.
If two words $w\in L$ and $w'\notin L$ have the same set of slice projections, then the language $L$ is not definable by slicing.
Recall that $1\,1\,2$ abbreviates the word $(1,1)(1,1)(1,2)$.
\begin{align*}
  && &w \in L &&w'\notin L && \{\,\pi_c(w\searrow\theta)\mid\theta\in\Theta\,\}\\
&L_1, L_5 &&1\,1\,2 &&1\,2\,2 &&\{1, 1\,1\} \\
&L_2 &&1 &&1\,2 && \{1\}\\
&L_3 &&1\,2\,2\,1 &&1\,1\,2\,2 &&\{1\,1\}
\end{align*}

The language $L_5$ is not definable by TOPL automata because the number of values held in registers is bounded.
The registers of a TOPL automaton store $\le m$ values out of $v_1\ldots v_{k-1}$.
Thus, it is not possible in general to decide if $v_k$ is among $v_1\ldots v_{k-1}$.
The language $L_4$ is not definable by TOPL automata for a similar reason.


Language $L_2$ is essentially the same as {\tt SingletonPattern} from \autoref{sec:examples}.
Language $L_3$ embodies a pattern, namely chaining of values, which occurs in {\tt ListNotCyclic}, {\tt IterateRopes}, and {\tt TaintCheck}.

In conclusion, registers and slicing are complementary methods\,---\,neither subsumes the other.
Several realistic properties that are definable by registers but not by slicing.

We conjecture that a certain generalization of TOPL automata subsumes slicing applied to regular languages.
This generalized model, history TOPL automata, have a special kind of register that holds sets of values, rather than single values.

% >>>
\section{Implementation} \label{sec:implementation} % <<<
We have implemented the formal framework in a tool\footnote{\url{http://rgrig.github.com/topl}} for checking whether a Java program violates
TOPL properties.
The tool consists of two parts: a compiler and a checker.
The TOPL compiler ({\tt toplc}) instruments Java bytecode;
The TOPL checker (class {\tt topl.Checker}) monitors the execution and reports violations.
\autoref{architecture} depicts how the compiler and the checker fit together, thus summarizing our runtime checking system.

\begin{figure}[t]
\begin{center}
\input{architecture}
\caption{Architecture of the TOPL tool}
\label{architecture}
\end{center}
\end{figure}

\paragraph{The TOPL Checker.} % <<<
The checker logs the property violations it detects.
Internally it  maintains a set of active states.
New states are  produced by applying an action to an existing state (called the parent).
For error reporting, each state keeps track of its parent.
The implementation takes advantage of this fact by representing stores
using persistent sets for bindings;  more precisely, we use treaps~\cite{DBLP:conf/focs/AragonS89}.

As states point to their parent, we need some mean to control overhead.  This is done by a configurable parameter for  the history length~$h$ in {\tt Property.java}.
We should then allow the Java~VM to garbage collect states that are not reachable in $h$~steps from some active state.
To do that, after each execution of a transition we could do a BFS traversal with $h$~steps and set to {\tt null} the parent pointer of fringe states.
However, for $n$~active states, the traversal would take $O(nh)$~time.
The procedure for executing transitions takes $O(nd)$~time, where $d$ is the maximum out-degree of the property.
So, the checker would become much slower if $h>d$, which usually is the case.
%
One solution could be to perform the BFS once in every $h/d$~steps.
The solution we implemented tries to better address the average case.
We remember the number~$m$ of states seen by a BFS, and perform the next BFS after $\sim m$~new states were created.

The set of active states in nondeterministic automata can be unbounded.
Therefore, as for the case of trace lengths, we impose a bound on the number of active states.
The bound can be configured by the user  in the {\tt Property.java}  file.
The  strategy for forgetting states can also be chosen among: {\em random}, {\em newest}, and {\em oldest}.
Newest\slash oldest refer to a time attached to states.
The time  of a state is the number of transitions  taken to reach that state.

% >>>
\paragraph{The TOPL Compiler.} \label{sec:toplc} % <<<
The compiler takes as input a Java project and a set of TOPL properties.
The Java project is defined to be all files in a given directory, recursively descending into jar and zip files as well as  subdirectories.
The compiler produces (1)~a copy of the Java project with the class files instrumented, and (2)~a TOPL automaton.
%The bytecode instrumentation and the construction of the TOPL automaton are intertwined.
Only the Java methods relevant to the given TOPL properties are instrumented, but taking into consideration
 the inheritance tree of  project.
For example, suppose that a TOPL property mentions the method {\tt next} from the interface {\tt Iterator}.
Then all the methods that implement {\tt Iterator.next} are instrumented and  matched by the automaton.
%
More in details the compiler execute  five phases.
%\begin{enumerate}
First, TOPL properties are converted into a simpler, intermediate format.
Second, the compiler  {\em staticically checks}  that the property is well-formed (e.g., variables writes must precede reads). We plan to also statically check whether the automaton can never fail.
%
Third,  all properties are merged into one automaton that is  dumped into the file {\tt Property.text}.
%
Fourth, the compiler generates the checker configurations in
the file {\tt Property.java}. This file contains
info used by the TOPL property and code configuring the checker.
Configuration parameters include:
\begin{itemize}
\item \emph{History length} -- how many events to remember.
  A high value reports more events that led to \error.
  A low value reduces the space and time overhead.
\item \emph{Maximum number of active states}.
  A high value increases the chances of detecting violations at the cost of higher  overhead.

\item \emph{Collect call stacks} is a flag for including/excluding  call stacks in violation reports.
%
\item {\em Approximantion method} gives different ways in which the history informations are forgotten when  the max amount of info
allowed is reached.
\end{itemize}
%
Fifth, the compiler instruments methods' bytecode.\footnote{To instrument Java bytecode we use a fork of the library
Barista~\cite{barista}.}

% >>>
% >>>
\section{Experimental Results}\label{sec:results} % <<<

We measure the overhead on the test suite DaCapo~\cite{dblp:conf/oopsla/dacapo}, version~9.12.
DaCapo is a collection of automated tests that exercise large portions of code from open-source projects and from the Java standard libraries.
DaCapo itself was used for many experiments by the research community.
Hence, we do not expect to find any bugs, but aim to measure the overhead.

We checked two types of properties with TOPL\null.
First, properties that express correct usage of the standard Java libraries.
Second, properties that express temporal constraints which we extracted from the code comments of three open-source projects, all of which are included in DaCapo.
The latter properties are more complex and interesting.

We measured both time and space overhead. It turns out that space
overhead is negligible, below the variance caused by the randomness of garbage collection.
So, we only report time overhead, in Tables~\ref{table:experiments}~and~\ref{table:overhead}.
%
All experiments are performed on an Intel i5 machine with $4$~cores at $3.33\rm\,GHz$ with  $4\rm\,GiB$ of memory and
running Linux~2.6.32 and Java VM~1.6.0\_20.

\subsection{JDK Properties} % <<<

These properties are taken from the JavaMOP project~\cite{dblp:journals/sttt/meredithjgcr12}.
\emph{HasNext}
 was briefly mentioned in \autoref{sec:topl_automata}. It
checks that no iterator is advanced without first calling {\tt hasNext}
and have it return {\tt true}.
\emph{UnsafeIterator}
 checks that no iterator is advanced after the iterated
collection has been modified. \rlp{Does this work? Would i.remove not
  call c.remove?}
\emph{UnsafeMapIterator}
 checks that no iterator on the keys or values of a map
is advanced after the map has been updated.
\emph{UnsafeFileWriter}
 checks that no file is written to after it has been closed.

\medskip
\autoref{table:experiments} presents the running times for DaCapo's projects with and without instrumentation of Java's standard library.
For each project there are two instrumented runs, one with a maximum of $3$~active configurations and one with a maximum of $10$ active configurations.
For properties involving only one object, such as {\tt HasNext}, a limit of $10$ means that at most that many objects are tracked \emph{at the same time}.


\begin{table}[t]
\begin{center}
\begin{tabular}{|l|r||r|r||r|r||r|r||r|r|} \hline
  & original  & \multicolumn{2}{|c||}{HasNext} & \multicolumn{2}{c||}{UnsafeIterator} &\multicolumn{2}{|c||}{UnsafeMapIterator} & \multicolumn{2}{|c|}{UnsafeFileWriter}
%  & orig.  & \multicolumn{2}{|c|}{$P_1$} & \multicolumn{2}{c|}{$P_2$} &\multicolumn{2}{|c|}{$P_3$} & \multicolumn{2}{|c|}{$P_4$}
  \\ \hline
  & & st=3 & st=10 & st=3 & st=10 & st=3 & st=10 & st=3 & st=10
  \\ \hline \hline
 avrora  & 8.1 & 27.8 & 60.5 & 163.3 & 323.1 & 194.5  & 179.9 & 8.3 & 5.9
 \\ \hline
 batik     &  1.2  & 18.1 &    3.0 & 3.8 &  3.8  & 3.1 &  3.3 & 1.3  &  1.2
 \\ \hline
eclipse   &  15.6  &  22.4 &  12.2X & 27.0 &  149.9X & 27.56 &  12.8X & 21.6 &  23.4
\\ \hline
fop    &   0.3   &  0.9 &  1.9 & 3.5  &  3.6   & 2.7 &   2.7 & 0.3 &   0.3
\\ \hline
h2     &    6.2  &  5.9 &  6.8   & 8.3    & 20.0  & 13.5 & 11.2   & 6.4 & 6.0
\\ \hline
jython    &  1.9  & 19.8 &  46.1 &  81.5   & 83.0  &  62.8 &       62.7    & 1.9 & 1.8
\\ \hline
luindex     &  0.8   & 0.8 &   0.8    & 0.8 & 0.9  & 1.0  &   0.9 & 0.8 & 0.9
\\ \hline
lusearch    &  1.5  &  1.5 &   1.5 & 15.0 &  16.0    & 13.8  &  12.8    & 1.5 & 1.7
\\ \hline
pmd        &   3.1    & 19.9 & 42.6  &  93.5 & 240.3   & 102.6 &       105.6  & 3.2 &           3.3
\\ \hline
sunflow    &  3.9   & 3.8 &  3.9  &  4.0 & 3.8    & 3.9 &        3.9     & 3.9 &         4.3
\\ \hline
tomcat     &   2.5    & 4.2 & 8.3   & 22.9 & 50.9   & 30.0 &        31.0   & 2.6 &          2.7
\\ \hline
%tradebeans  &  5475  &  XX &     XX  & XX &    XX     & XX &          XX    & XX &           XX
%\\ \hline
%tradesoap   & 6937   &  XX &    XX    & XX &  XX       & XX &       XX       & XX &        XX
%\\ \hline
xalan      &    1.5   &  14.5      & 7.1 & 425.0  & 360.9 &  272.0   & 276.5 &  1.5 & 1.2
\\ \hline
\end{tabular}
\end{center}
\caption{Experiment on small properties run on the DaCapo benchmarks
  (run in convergence mode). Times are in seconds.}
\label{table:experiments}%\label{tab:javamop-experiments}
\end{table}

% >>>
\subsection{DaCapo Properties} % <<<
We focus on $3$~projects that are still widely developed and used:
Tomcat, H2, and PMD\null.

All three benchmarks are large open-source projects with many users and active developers.
The versions were current in 2009 when DaCapo-9.12 was released.

\paragraph{Tomcat 6.0.20.}
Tomcat is a highly concurrent servlet server.
Servlets are Java programs running in a webserver, extracting data from {\tt ServletRequest}s , and sending data to {\tt ServletResponse}s.
A response has two associated incoming channels: a stream and a writer. Both should not be used concurrently.
%Property~\eqref{eq:prop-ws-strong} is a strong interpretation of this constraint;
%property~\eqref{eq:prop-ws-weak} is a weak interpretation of this constraint.
A response could be forwarded once the servlet sent data to it.

But the servlet, before forwarding the response, must call {\tt flush} on the stream, on ther writer, or on the response itself.
This is one of two properties we checked. The other is given an
anecdotal description at the end of the section.


\paragraph{H2 1.2.121.}
H2 is a database server.
We checked four properties for it.
Three properties express constraints on the order in which the methods of an interface may be called.
For example, a client should not attempt to ask for a row from a cursor that did not advance;
that is, ``{\em for the interface {\tt Cursor}, the method {\tt next} must be called before calling method {\tt getSearchRow}}''.
The fourth property describes the contract of the class {\tt SysConstants}.
This class reads environment variables when it is loaded.
Its comments say that {\em ``it is legal for a program to set these environment variables using the method {\tt System.setProperty}, provided that this is done before the Java VM loads the class {\tt SysConstants}''}.
It is easy to specify this property because TOPL intentionally treats the special methods {\tt <init>} and {\tt <clinit>} as if they are normal methods.

\paragraph{PMD 4.2.5.}
PMD looks for bugs, dead code, and a few other problems in Java code.
We checked five properties for it.
One of the five involves two objects:
{\em ``A scope should be asked what is the definition of a name only if it already replied that it knows the name''}.

\medskip
\autoref{table:overhead} summarizes the experimental results.
The reference column shows the running time without any instrumentation.
A timeout signifies a time greater than the reference time~$\times100$.
All reported times are averaged over $10$~runs, and are accompanied by the unbiased estimate of standard deviation.
In theory the set of active states is unbounded, but we impose a size limit on it.
The table reports the running times for the instrumented bytecode when the size limit is $0$, $10^1$, $10^2$.
For h2 the running time is more than $\times1.4$ the reference time even when the TOPL checker is not tracking any active state.
This indicates that we instrumented a simple method that runs often.

\begin{table}[t]\centering
\begin{tabular}{@{}rr@{}lr@{}lr@{}lr@{}l}
  &&
  & \multicolumn{6}{c}{Number of tracked active states} \\ \cmidrule{4-9}
& \multicolumn{2}{c}{reference}
  &\multicolumn{2}{c}{$\le0$}
  &\multicolumn{2}{c}{$\le10^1$}
  &\multicolumn{2}{c}{$\le10^2$}
%  &\multicolumn{2}{c}{$\le10^3$}
%  &\multicolumn{2}{c}{$\le10^4$}
\\ \midrule
tomcat
  & $5.3$ & $\pm0.1$
  & $5.4$ & $\pm0.1$
  & $5.6$ & $\pm0.2$
  & $9.0$ & $\pm0.3$
%  & $43.5$ & $\pm1.2$
%  & $43.9$ & $\pm1.0$
\\
pmd
  & $5.2$ & $\pm0.4$
  & $5.4$ & $\pm0.2$
  & $12.2$ & $\pm0.3$
  & $47.7$ & $\pm10.7$
%  & \multicolumn{2}{c}{timeout}
%  & \multicolumn{2}{c}{timeout}
  \\
h2
  & $6.6$ & $\pm0.2$
  & $9.5$ & $\pm0.2$
  & $130.1$ & $\pm12.2$
  & \multicolumn{2}{c}{timeout}
%  & \multicolumn{2}{c}{timeout}
%  & \multicolumn{2}{c}{timeout}
  \\
\end{tabular}
\caption{
  Experimental Results.
  Times are in seconds, averaged over $10$~runs.
}\label{table:overhead}
\end{table}

% >>>
\paragraph{A Bug's Death.} % <<<

The interface \texttt{ServletResponse} from Tomcat contains methods \texttt{getWriter} and \texttt{getOutputStream}.
The documentation of \texttt{getWriter} states that ``either this method or \texttt{getOutputStream} may be called to write the body, not both''.
We initially interpreted this comment as follows.
\eqquote{It is illegal to call both the method {\tt getWriter} and the method {\tt getOutputStream} on the same instance of {\tt ServletResponse}.}{eq:prop-ws-strong}
The TOPL checker reported many violations of~\eqref{eq:prop-ws-strong}.
We were not too surprised because we were unsure of the intended meaning of the comment.
We were surprised, however, that sometimes a {\tt null} dereference occurred in DaCapo itself.
We investigated.
The statement that threw a {\tt null}-pointer exception was the following:
\begin{align}\label{eq:npe-src}
\text{\Verb@if (log != null) log.write(b);@}
\end{align}
It must be that a concurrent thread sets {\tt log} to~{\tt null}.
The statement is located in the method {\tt write} of the class {\tt TeeOutputStream}.
The only method that sets {\tt log} to~{\tt null} is {\tt closeLog}, from the same class.
So, we wrote a TOPL property saying that \textit{executions of {\tt write} and {\tt closeLog} must not overlap in time}, and we asked for error reports that include call stacks.
Indeed, DaCapo's main loop sometimes calls {\tt closeLog} while the Tomcat server is printing.

TOPL helped us find a concurrency bug in the infrastructure of DaCapo.
First, the bytecode instrumented by TOPL helped us notice the problem.
The reason is \emph{not} that a certain interleaving became more likely.
Bug~2934521 of DaCapo mentions that exceptions of the Tomcat benchmark are silently ignored.
This is why the {\tt null}-dereference was not noticed before.
The TOPL checker tried to report an unrelated issue to {\tt System.err}.
DaCapo had redirected the standard error stream to its own class, which faulted.
TOPL caught the error and reported it as an internal issue, because no exceptions should be thrown while running the TOPL checker.
Second, TOPL helped us identify the data race.
It would have been more difficult to figure out which threads exactly used the stream simultaneously.

We then tried a weaker version of property~\eqref{eq:prop-ws-strong}:
\eqquote{Stream and writer of a response cannot both be used.}
{eq:prop-ws-weak}
This property\footnote{\url{http://goo.gl/V008y}} involves three related objects.
It turns out this property is also violated.
After reading the code to which the error traces pointed at, we noticed that the comments of some implementing classes weaken the contract:
They say that the stream and the response cannot be used without an intervening {\tt reset}.
In this case the comments on the interface {\tt ServletResponse} are arguably wrong, rather than the code.
This brings out another advantage of TOPL:
Since TOPL properties are processed by tools, they are less likely to become out-of-sync with the code.

%>>>
%>>>
\section{Related Work}\label{sec:related} %<<<

TOPL automata are a variant of {\it register automata\/}~\cite{dblp:conf/focs/kaminskif90}.
We proved that several decidability results known for register automata also hold for TOPL automata.
Register automata work with infinite alphabets, as do a few other types of automata~\cite{dblp:conf/csl/segoufin06}.
Until now, such automata found applications mostly related to databases and XML\null.
Intuitively, however, such models are a good fit for expressing properties of programs because the set of program values is infinite.
For example objects could be instantiated inside non-terminating loops.
Our paper exhibits a working runtime verification system based on register automata, thus validating the intuition.

{\it QVM\/}~\cite{arnold:2008} is a system for runtime monitoring of applications that are deployed.
As such, QVM's main goal is efficiency, and it achieves it because
(1)~it is carefully implemented inside a Java virtual machine,
(2)~it checks properties involving a single object,
(3)~it adapts on-the-fly the rate of sampling objects to monitor, such that the overhead remains within a given budget.
On the other hand, TOPL aims to help during development and testing.
Thus, having a precise and expressive language for specifying temporal properties takes precedence over efficiency.
For example TOPL can express properties involving many objects, even if monitoring such properties typically imposes a bigger overhead.
Both QVM and TOPL let the programmer tune the overhead\slash coverage balance.
In QVM's case the programmer directly chooses the percentage of time spent monitoring, which is intuitive;
in TOPL's case the programmer chooses a more abstract parameter, the number of active configurations, which correlates with the overhead.

{\it JavaMOP\/}~\cite{dblp:journals/sttt/meredithjgcr12} and {\it tracematches\/}~\cite{dblp:conf/oopsla/allanachklmsst05} are the main runtime verification systems that handle multiple objects.
They differ in many details, but the essential ideas fit a common intuition.
To communicate this intuition we depart from the terminologies of \cite{dblp:journals/sttt/meredithjgcr12}~and~\cite{dblp:conf/oopsla/allanachklmsst05}.
The alphabet is~$\Sigma=C\times V$, where $C$~is a finite set of constants and $V$~is an infinite set of values.
The task is to build a recognizer $\Sigma^*\to\B$.
Both approaches build upon a basic recognizer $C^*\to\B$ over finite alphabets.
Tracematches specify this recognizer by regular expressions, while JavaMOP supports several other logics.
Both approaches make further assumptions on the structure of~$V$, and then define a way to specify a family $P\subset\Sigma\to\B$ of predicates over letters.
Each such predicate~$p\in P$ determines a slice $\tau_p\in C^*$ of the trace $\tau\in\Sigma^*$ by retaining exactly those constants from letters satisfying~$p$.
The trace~$\tau$ is recognized when any of its slices satisfy the basic recognizer.
Within such a framework, it seems difficult to express some of our examples, which naturally use an unbounded number of assignments to registers.

Any algorithm that analyzes or transforms JavaMOP properties must be specific to a certain plugin because the formalization of the framework~\cite{dblp:journals/corr/abs-1112-5761} imposes no constraint on recognizers $C^*\to\B$.
In contrast, any algorithmic result discovered for register automata implies one for TOPL properties.
For example we know that the emptiness problem is decidable, and we know that it is impossible to compute the negation of a property.

{\it Tracematches\/}~\cite{dblp:conf/oopsla/allanachklmsst05} are likely to have the same expressivity as JavaMOP with the plugin for regular expressions.
But, we are unaware of a fully formal comparison.
Tracematches evolved from the work on aspect-oriented programming.
Unsurprisingly, the user may specify arbitrary code to run when a match is found.
The formal semantics ignore this arbitrary code and how it could influence further matches.

{\it ConSpec\/}~\cite{DBLP:journals/entcs/AktugN08} is a language used to describe security policies.
Because ConSpec automatons are deterministic and have only a countable number of states, they cannot in principle express the property \texttt{InvalidateOtherIterators} (see Figure~\ref{fig:first.topl}).



From the techniques used mostly for static verification of object-oriented programs, {\it typestates\/}~\cite{strom1986} are probably most similar to TOPL\null.
A modular static verification method for typestate protocols is introduced in~\cite{dblp:conf/oopsla/bierhoffa07}.
The specification method is based on linear logic and relations among objects in the protocol are monitored by a tailored system of permissions.
The specification of the interactions among objects by means of permissions adds an extra level of machinery which increases the gap between the intuitive protocol description and its formalization.
Similarly~\cite{deline2004,dblp:conf/sigsoft/BierhoffA05} provide a mean to specify typestate properties that belong to a single object.
The specified properties are reminiscent of contracts or pre/post-conditions for methods and can deal with inheritance.
In~\cite{dblp:conf/issta/FinkYDRG06} the authors present sound verification techniques for typestate properties of Java  programs.
Their approach is divided in several stages with different verifiers varying for cost and precision.
In the early stages efficient but imprecise analyses are employed whereas more expensive and precise techniques are then progressively employed in later stages.
Every stage focuses on verifying only the parts of the code that previous stages failed to verify.
It is likely that  TOPL could be fruitfully combined with their analysis technique.

A specification language for interface checking aimed at C programs (called {\it SLIC\/}) is introduced in~\cite{ball2002}.
Differences between SLIC and TOPL include: the use (in SLIC) of non-determinism to encode universal quantification of dynamically allocated data, and the  ability to have complex code in the automaton transitions.
TOPL specifications naturally express universally quantified properties over data structures and for computability reasons,  we have chosen to limit the  actions performed during automaton transitions.
Simple SLIC specifications are verified by  the SLAM verifier~\cite{dblp:conf/cav/ballr01}.
While SLAM specialises on device drivers and checks client conformance rather than full protocols,
very general specifications of object-oriented program behaviour can be given in JML~\cite{jml} and Spec$^\sharp$~\cite{DBLP:journals/jot/BarnettDFLS04}. However the latter two languages focus on class specifications and do not have temporal features.

Finally, there are similar investigations going on in the functional programming community.
In~\cite{disney2011} contracts are used to express legal traces of programs in a functional language with references.
The contracts specify traces as regular expressions over calls and returns, and hence, they resemble our automata, in a quite different setting.
Here, the specifications are function-centered, though, and again, capturing inter-object relations seems somewhat tricky.

% >>>
\section{Conclusions and Future Work}\label{sec:conclusions} %<<<
In this paper we have introduced TOPL a new runtime verification system aimed at checking temporal safety properties of object-oriented programs.
For TOPL we have defined solid formal foundations based on register automata. Moreover we have studied the formal correspondence between TOPL automata and register automata proving that they are equally expressive.
TOPL has been implemented in a practical tool that we have applied  to a variety of programs including large open source Java projects.
%

%\paragraph{Future work.}
In the future, we intend to combine TOPL with  separation logic~\cite{reynolds2002} in order to deal with the heavy use of the heap and aliasing in object-oriented software.
Moreover, we aim at developing static analysis techniques for TOPL properties using the jStar framework~\cite{DBLP:conf/oopsla/DistefanoP08}.
This will require investigating suitable abstraction for obtaining meaningful and precise over-approximations of the state space of the programs.
Finally, we intend to develop a tailored bi-abduction inference technology~\cite{dblp:conf/popl/CalcagnoDOY09} which would help with scalability of the analysis.

%>>>
\bibliographystyle{abbrv} % and appendix <<<
\bibliography{safety}

% \appendix
% \section{TOPL Syntax}
% \label{app:syntax}
% \begin{tabular}{l}
% \grammar{
%   Property& \b{property} Identifier Item\* \cr
%   Item& Prefix \| Observe \| Transition \cr
%   Prefix& \b{prefix} \b< StringPattern \b> \cr
%   Observe& \b{observe} \b< StringPattern \b> \cr
%   Transition& Arc \b: Label \(\b, Label\)\* \cr
%   StringPattern& \(Letter \| \b. \| \b* \| \b{\{} \| \b{\}} \| \b, \)\+ \cr
%   Arc& Vertex \b{->} Vertex \cr
%   Label& Tag\? MethodPattern \cr
%   Vertex& Identifier \cr
%   Tag& \b{call} \| \b{return} \cr
%   MethodPattern& ResultPattern\? NamePattern ArgumentsPattern \cr
%   ResultPattern& ValuePattern \b{:=} \cr
%   NamePattern& StringPattern \cr
%   ArgumentsPattern& \b( \(ValuePattern \(\b, ValuePattern\)\*\)\? \b) \cr
%   ArgumentsPattern& \b[ IntegerPattern \b] \cr
%   ValuePattern& \b* \| \b< Literal \b> \| UppercaseId \| LowercaseId \cr
%   IntegerPattern& \b* \| IntegerLiteral \cr
% }
% \end{tabular}

%
%\begin{figure*}[h]\label{fig:tomcat-prop}
%\begin{Verbatim}
%property InterleavedResponse2
%  // vertex names: w = got writer; W = used writer; similarly for s, S
%  message "Incompatible methods for putting data into a response were used."
%  observe <javax.servlet.ServletOutputStream.*>
%  observe <java.io.PrintWriter.*>
%  observe <javax.servlet.ServletResponse.{getOutputStream,getWriter}>
%  prefix <javax.servlet.ServletResponse>
%  start -> start: *
%  start -> w: W := R.getWriter()
%  start -> s: S := R.getOutputStream()
%  w -> sw: S := r.getOutputStream()
%  s -> sw: W := r.getWriter()
%  w -> W: w.*
%  sw -> sW: w.*
%  s -> S: s.*
%  sw -> Sw: s.*
%  W -> sW: S := r.getOutputStream()
%  S -> Sw: W := r.getWriter()
%  sW -> error: s.*
%  Sw -> error: w.*
%\end{Verbatim}
%\caption{Example Tomcat Propery}
%\end{figure*}

% >>>
\end{document}
%% vim:spell errorformat=%f\:%l-%m,%f\:%l\:%m,%f\:%m
%% vim:fmr=<<<,>>>:
